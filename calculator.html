<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Scientific Calculator + Grapher (MathML + AST→LaTeX)</title>

  <!-- MathJax for MathML consistency -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-chtml.js"></script>

  <style>
    :root{ --bg:#0b1220; --panel:#071025; --muted:#9aa4b2; --accent:#22d3ee; --glass: rgba(255,255,255,0.03); }
    *{box-sizing:border-box}
    body{ margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center; background: linear-gradient(180deg,#031127,#071829); color:#e6eef6; font-family:Inter, system-ui, Arial; padding:24px; }
    .app{ width: min(1100px,96vw); display:grid; grid-template-columns: 480px 1fr; gap:20px; }
    .panel{ background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); padding:16px; border-radius:12px; }
    .display{ background:var(--glass); border-radius:10px; padding:12px; min-height:92px; display:flex; flex-direction:column; gap:8px; }
    .top-row{display:flex; gap:8px; align-items:center; justify-content:space-between}
    .math-display{flex:1; text-align:right; font-size:18px}
    .result-display{ text-align:right; font-size:22px; font-weight:600; color:var(--accent) }
    .kbd{ margin-top:12px; display:grid; grid-template-columns: repeat(6, 1fr); gap:8px }
    button.key{ background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02)); padding:12px 8px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); color:#dbe8ef; font-size:15px; cursor:pointer }
    button.key:active{ transform:translateY(1px) }
    .op{ color:#ffd27a } .fn{ color:#a9d5ff } .wide{ grid-column: span 2 } .eq{ background:linear-gradient(180deg,#0ea5e9,#22d3ee); color:#032027 }
    .side{ display:flex; flex-direction:column; gap:12px }
    .history{ max-height:360px; overflow:auto; padding:8px; border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.008)); }
    .hist-item{ display:flex; justify-content:space-between; gap:8px; padding:8px; border-radius:8px; align-items:center }
    .hist-expression{ font-size:14px; color:var(--muted) } .hist-result{ font-weight:600; color:var(--accent) }
    .btn-ghost{ background:transparent; border:1px dashed rgba(255,255,255,0.03); padding:6px 8px; border-radius:8px; cursor:pointer; color:var(--muted) }
    .controls{ display:flex; gap:8px; margin-top:8px }
    .tabs{ display:flex; gap:8px; margin-bottom:8px }
    .tab{ padding:8px 10px; border-radius:8px; background:transparent; border:1px solid rgba(255,255,255,0.02); cursor:pointer; color:var(--muted) }
    .tab.active{ background:linear-gradient(90deg,#06283a,#083047); color:var(--accent) }
    .graph-canvas{ width:100%; height:420px; background:#071322; border-radius:8px; border:1px solid rgba(255,255,255,0.03) }
    .small{ font-size:13px; color:var(--muted) }
    @media (max-width:980px){ .app{ grid-template-columns:1fr } }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <div style="display:flex; justify-content:space-between; align-items:center">
        <h2 style="margin:0">Scientific Calculator + Grapher</h2>
        <div class="tabs">
          <button class="tab active" id="calcTab">Calculator</button>
          <button class="tab" id="graphTab">Grapher</button>
        </div>
      </div>

      <!-- Calculator -->
      <div id="calcArea">
        <div style="display:flex; justify-content:space-between; align-items:center; margin:10px 0">
          <div>
            <button id="degBtn" class="btn-ghost">DEG</button>
            <button id="radBtn" class="btn-ghost active">RAD</button>
          </div>
          <div class="small">Mode: <span id="modeLabel">RAD</span></div>
        </div>

        <div class="display" aria-live="polite">
          <div class="top-row">
            <div class="math-display" id="exprMath"></div>
            <div style="text-align:right">
              <div class="small">Ans</div>
              <div class="result-display" id="ansMath"></div>
            </div>
          </div>
          <div id="resultLine" class="result-display"></div>
        </div>

        <div class="kbd" id="buttons">
          <!-- Row 1 -->
          <button class="key fn" data-insert="sin(">sin</button>
          <button class="key fn" data-insert="cos(">cos</button>
          <button class="key fn" data-insert="tan(">tan</button>
          <button class="key fn" data-insert="asin(">asin</button>
          <button class="key fn" data-insert="acos(">acos</button>
          <button class="key fn" data-insert="atan(">atan</button>

          <!-- Row 2 -->
          <button class="key fn" data-insert="sinh(">sinh</button>
          <button class="key fn" data-insert="cosh(">cosh</button>
          <button class="key fn" data-insert="tanh(">tanh</button>
          <button class="key fn" data-insert="log10(">log</button>
          <button class="key fn" data-insert="ln(">ln</button>
          <button class="key fn" data-insert="exp(">e^x</button>

          <!-- Row 3 -->
          <button class="key" data-insert="7">7</button>
          <button class="key" data-insert="8">8</button>
          <button class="key" data-insert="9">9</button>
          <button class="key op" data-insert="/">÷</button>
          <button class="key op" data-insert="(">(</button>
          <button class="key op" data-insert=")">)</button>

          <!-- Row 4 -->
          <button class="key" data-insert="4">4</button>
          <button class="key" data-insert="5">5</button>
          <button class="key" data-insert="6">6</button>
          <button class="key op" data-insert="*">×</button>
          <button class="key op" data-insert="^">^</button>
          <button class="key fn" data-insert="sqrt(">√</button>

          <!-- Row 5 -->
          <button class="key" data-insert="1">1</button>
          <button class="key" data-insert="2">2</button>
          <button class="key" data-insert="3">3</button>
          <button class="key op" data-insert="-">−</button>
          <button class="key fn" data-insert="root(">y√x</button>
          <button class="key fn" data-insert="abs(">abs</button>

          <!-- Row 6 -->
          <button class="key wide" data-insert="0">0</button>
          <button class="key" data-insert=".">.</button>
          <button class="key eq wide" id="equals">=</button>
          <button class="key op" data-insert="+">+</button>

          <!-- Row 7 -->
          <button class="key fn" data-insert="pi">π</button>
          <button class="key fn" data-insert="e">e</button>
          <button class="key fn" id="factBtn" data-insert="!">x!</button>
          <button class="key fn" id="nCrBtn" data-insert="nCr(">nCr</button>
          <button class="key fn" id="nPrBtn" data-insert="nPr(">nPr</button>
          <button class="key" id="clear">C</button>

          <!-- Row 8 -->
          <button class="key" id="mplus">M+</button>
          <button class="key" id="mminus">M-</button>
          <button class="key" id="mr">MR</button>
          <button class="key" id="mc">MC</button>
          <button class="key" id="ansBtn">Ans</button>
          <button class="key" id="back">⌫</button>
        </div>

        <div style="display:flex; gap:8px; margin-top:12px">
          <button class="btn-ghost" id="copyExpr">Copy Expr LaTeX (AST)</button>
          <button class="btn-ghost" id="copyResult">Copy Result LaTeX</button>
          <button class="btn-ghost" id="clearHistory">Clear History</button>
        </div>

      </div>

      <!-- Grapher -->
      <div id="graphArea" style="display:none; margin-top:10px">
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px">
          <input id="graphExpr" style="flex:1; padding:8px; border-radius:6px; border:1px solid rgba(255,255,255,0.03); background:transparent; color:inherit" placeholder="Enter function of x, e.g. sin(x)/x or x^2 - 3*x + 2" />
          <button class="btn-ghost" id="plotBtn">Plot</button>
        </div>
        <div style="display:flex; gap:8px; margin-bottom:8px">
          <div style="display:flex; gap:6px; align-items:center" class="small">x-min <input id="xmin" value="-10" style="width:80px; padding:6px; border-radius:6px; background:transparent; border:1px solid rgba(255,255,255,0.03)" /></div>
          <div style="display:flex; gap:6px; align-items:center" class="small">x-max <input id="xmax" value="10" style="width:80px; padding:6px; border-radius:6px; background:transparent; border:1px solid rgba(255,255,255,0.03)" /></div>
          <div style="display:flex; gap:6px; align-items:center" class="small">samples <input id="samples" value="800" style="width:80px; padding:6px; border-radius:6px; background:transparent; border:1px solid rgba(255,255,255,0.03)" /></div>
          <div style="display:flex; gap:6px; align-items:center" class="small">y-scale <input id="yscale" value="1" style="width:80px; padding:6px; border-radius:6px; background:transparent; border:1px solid rgba(255,255,255,0.03)" /></div>
        </div>
        <canvas id="graphCanvas" class="graph-canvas"></canvas>
        <div class="small" style="margin-top:8px">Use <code>x</code> variable. DEG/RAD toggle affects trig evaluation.</div>
      </div>

    </div>

    <!-- RIGHT: history & help -->
    <div class="panel side">
      <div>
        <h3 style="margin:0 0 8px 0">History</h3>
        <div class="history" id="historyList" aria-live="polite"></div>
      </div>

      <div style="margin-top:12px">
        <h4 style="margin:6px 0">Quick help</h4>
        <ul class="small" style="margin:6px 0 0 18px">
          <li>Functions: <code>sin(x)</code>, <code>sqrt(x)</code>, <code>root(n,x)</code>, <code>nCr(n,k)</code>.</li>
          <li>Constants: <code>pi</code>, <code>e</code>, <code>Ans</code>.</li>
          <li>Keyboard: <code>Enter</code>=eval, <code>Backspace</code>=erase, <code>Esc</code>=clear.</li>
        </ul>
      </div>
    </div>
  </div>

<script>
(() => {
  // UI refs
  const exprMath = document.getElementById('exprMath');
  const ansMath = document.getElementById('ansMath');
  const resultLine = document.getElementById('resultLine');
  const buttons = document.getElementById('buttons');
  const historyList = document.getElementById('historyList');

  const calcTab = document.getElementById('calcTab');
  const graphTab = document.getElementById('graphTab');
  const calcArea = document.getElementById('calcArea');
  const graphArea = document.getElementById('graphArea');
  const graphExpr = document.getElementById('graphExpr');
  const plotBtn = document.getElementById('plotBtn');
  const graphCanvas = document.getElementById('graphCanvas');
  const xminEl = document.getElementById('xmin');
  const xmaxEl = document.getElementById('xmax');
  const samplesEl = document.getElementById('samples');
  const yscaleEl = document.getElementById('yscale');

  const degBtn = document.getElementById('degBtn');
  const radBtn = document.getElementById('radBtn');
  const modeLabel = document.getElementById('modeLabel');
  let DEG = false; // rad by default

  // state
  let expression = '';
  let lastAns = 0;
  let memory = 0;
  const history = [];

  // operators & functions metadata
  const OPERATORS = {
    '+': {prec:1, assoc:'L', args:2},
    '-': {prec:1, assoc:'L', args:2},
    '*': {prec:2, assoc:'L', args:2},
    '/': {prec:2, assoc:'L', args:2},
    '^': {prec:4, assoc:'R', args:2},
    '!': {prec:5, assoc:'L', args:1, postfix:true}
  };
  const FUNCTIONS = new Set(['sin','cos','tan','asin','acos','atan','sinh','cosh','tanh','asinh','acosh','atanh','sqrt','root','log10','ln','exp','abs','nCr','nPr']);

  // --- tokenizer
  function tokenize(str){
    const tokens = []; let i=0;
    while(i<str.length){
      const ch = str[i];
      if(/\s/.test(ch)){ i++; continue; }
      if(/[0-9.]/.test(ch)){
        let num = ch; i++;
        while(i<str.length && /[0-9.]/.test(str[i])) num += str[i++];
        tokens.push({type:'num', value: parseFloat(num)}); continue;
      }
      if(/[A-Za-zπ]/.test(ch)){
        let id = ch; i++;
        while(i<str.length && /[A-Za-z0-9_]/.test(str[i])) id += str[i++];
        if(id === 'π') id = 'pi';
        tokens.push({type:'id', value: id}); continue;
      }
      if(ch === ','){ tokens.push({type:'comma'}); i++; continue; }
      if(ch === '(' || ch === ')'){ tokens.push({type:'paren', value: ch}); i++; continue; }
      if(['+','-','*','/','^','!'].includes(ch)){ tokens.push({type:'op', value: ch}); i++; continue; }
      i++;
    }
    return tokens;
  }

  // --- shunting-yard to RPN
  function toRPN(tokens){
    const output=[]; const stack=[];
    for(let i=0;i<tokens.length;i++){
      const t = tokens[i];
      if(t.type === 'num'){ output.push(t); continue; }
      if(t.type === 'id'){
        const next = tokens[i+1];
        if(next && next.type==='paren' && next.value==='(' && FUNCTIONS.has(t.value)) stack.push({type:'func', value:t.value});
        else output.push(t);
        continue;
      }
      if(t.type === 'op'){
        const o1 = t.value;
        if(o1 === '-'){
          const prev = tokens[i-1];
          const isUnary = (!prev) || (prev.type==='op' && prev.value!=='!') || (prev.type==='paren' && prev.value==='(') || prev.type==='comma';
          if(isUnary){ stack.push({type:'op', value:'u-', prec:6, assoc:'R', args:1}); continue; }
        }
        const meta = OPERATORS[o1]||{prec:0,assoc:'L'};
        while(stack.length){
          const top = stack[stack.length-1];
          const p2 = (top.type==='op') ? (top.prec || OPERATORS[top.value]?.prec||0) : 10;
          const assoc = (top.type==='op') ? (OPERATORS[top.value]?.assoc||'L') : 'L';
          if((assoc==='L' && meta.prec <= p2) || (assoc==='R' && meta.prec < p2)){ output.push(stack.pop()); continue; }
          break;
        }
        stack.push({type:'op', value:o1, prec:meta.prec, assoc:meta.assoc, args: meta.args || 2, postfix: meta.postfix||false});
        continue;
      }
      if(t.type === 'paren'){
        if(t.value === '(') stack.push(t);
        else { while(stack.length && !(stack[stack.length-1].type==='paren' && stack[stack.length-1].value==='(')) output.push(stack.pop()); if(!stack.length) throw new Error('Mismatched parentheses'); stack.pop(); if(stack.length && stack[stack.length-1].type==='func') output.push(stack.pop()); }
        continue;
      }
      if(t.type === 'comma'){ while(stack.length && !(stack[stack.length-1].type==='paren' && stack[stack.length-1].value==='(')) output.push(stack.pop()); if(!stack.length) throw new Error('Misplaced comma'); continue; }
    }
    while(stack.length){ const t=stack.pop(); if(t.type==='paren') throw new Error('Mismatched parentheses'); output.push(t); }
    return output;
  }

  // --- RPN -> AST
  function rpnToAST(rpn){
    const st = [];
    for(const token of rpn){
      if(token.type === 'num') st.push({type:'num', value: token.value});
      else if(token.type === 'id') st.push({type:'id', value: token.value});
      else if(token.type === 'op'){
        if(token.value === 'u-'){ const a = st.pop(); st.push({type:'op', op:'u-', args:[a]}); }
        else if(token.postfix){ const a = st.pop(); st.push({type:'op', op:token.value, args:[a]}); }
        else { const b = st.pop(); const a = st.pop(); st.push({type:'op', op:token.value, args:[a,b]}); }
      } else if(token.type === 'func'){
        const name = token.value;
        if(name==='root' || name==='nCr' || name==='nPr'){ const b = st.pop(); const a = st.pop(); st.push({type:'func', name, args:[a,b]}); }
        else { const a = st.pop(); st.push({type:'func', name, args:[a]}); }
      }
    }
    if(st.length !== 1) throw new Error('Invalid AST');
    return st[0];
  }

  // --- AST -> LaTeX (well-formed) ---
  function astToLatex(node){
    if(!node) return '';
    if(node.type === 'num') return (Number.isFinite(node.value) ? String(node.value) : String(node.value));
    if(node.type === 'id'){
      if(node.value === 'pi') return '\\\\pi';
      if(node.value === 'Ans') return '\\\\mathrm{Ans}';
      return node.value;
    }
    if(node.type === 'op'){
      const op = node.op;
      if(op === 'u-') return '-' + wrapIfNeeded(node.args[0]);
      if(op === '+') return `${wrapIfNeeded(node.args[0])} + ${wrapIfNeeded(node.args[1])}`;
      if(op === '-') return `${wrapIfNeeded(node.args[0])} - ${wrapIfNeeded(node.args[1])}`;
      if(op === '*') return `${wrapIfNeeded(node.args[0])} \\\\cdot ${wrapIfNeeded(node.args[1])}`;
      if(op === '/') return `\\\\frac{${astToLatex(node.args[0])}}{${astToLatex(node.args[1])}}`;
      if(op === '^') return `{${astToLatex(node.args[0])}}^{${astToLatex(node.args[1])}}`;
      if(op === '!') return `${astToLatex(node.args[0])}!`;
    }
    if(node.type === 'func'){
      const n = node.name; const a = node.args;
      if(n === 'sqrt') return `\\\\sqrt{${astToLatex(a[0])}}`;
      if(n === 'root') return `\\\\sqrt[${astToLatex(a[0])}]{${astToLatex(a[1])}}`;
      if(n === 'log10') return `\\\\log_{10}\\left(${astToLatex(a[0])}\\right)`;
      if(n === 'ln') return `\\\\ln\\left(${astToLatex(a[0])}\\right)`;
      if(n === 'exp') return `e^{${astToLatex(a[0])}}`;
      if(n === 'nCr') return `\\\\binom{${astToLatex(a[0])}}{${astToLatex(a[1])}}`;
      if(n === 'nPr') return `P\\left(${astToLatex(a[0])},${astToLatex(a[1])}\\right)`;
      return `\\\\${n}\\\\left(${astToLatex(a[0])}\\\\right)`;
    }
    return '';
    function wrapIfNeeded(child){
      if(child.type === 'op' && (child.op === '+' || child.op === '-' || child.op === 'u-')) return `\\\\left(${astToLatex(child)}\\\\right)`;
      return astToLatex(child);
    }
  }

  // --- Evaluate RPN with variable support ---
  function evalRPN(rpn, vars = {}){
    const st = [];
    for(const token of rpn){
      if(token.type === 'num') st.push(token.value);
      else if(token.type === 'id'){
        const v = token.value;
        if(v === 'pi') st.push(Math.PI);
        else if(v === 'e') st.push(Math.E);
        else if(v === 'Ans') st.push(lastAns);
        else if(Object.prototype.hasOwnProperty.call(vars, v)) st.push(vars[v]);
        else throw new Error('Unknown identifier: ' + v);
      } else if(token.type === 'op'){
        const op = token.value;
        if(op === 'u-'){ const a=st.pop(); st.push(-a); continue; }
        if(op === '!'){ const a=st.pop(); st.push(factorial(a)); continue; }
        const b=st.pop(); const a=st.pop();
        switch(op){ case '+': st.push(a+b); break; case '-': st.push(a-b); break; case '*': st.push(a*b); break; case '/': st.push(a/b); break; case '^': st.push(Math.pow(a,b)); break; default: throw new Error('Unknown op'); }
      } else if(token.type === 'func'){
        const fn = token.value;
        if(fn === 'sin'||fn==='cos'||fn==='tan'||fn==='asin'||fn==='acos'||fn==='atan'||fn==='sinh'||fn==='cosh'||fn==='tanh'||fn==='asinh'||fn==='acosh'||fn==='atanh'){
          const a = st.pop(); st.push(applyTrig(fn,a)); continue;
        }
        if(fn === 'sqrt'){ const a=st.pop(); st.push(Math.sqrt(a)); continue; }
        if(fn === 'root'){ const x = st.pop(); const n = st.pop(); st.push(Math.pow(x,1/n)); continue; }
        if(fn === 'log10'){ const a=st.pop(); st.push(Math.log10 ? Math.log10(a) : Math.log(a)/Math.LN10); continue; }
        if(fn === 'ln'){ const a=st.pop(); st.push(Math.log(a)); continue; }
        if(fn === 'exp'){ const a=st.pop(); st.push(Math.exp(a)); continue; }
        if(fn === 'abs'){ const a=st.pop(); st.push(Math.abs(a)); continue; }
        if(fn === 'nCr'){ const r = st.pop(); const n = st.pop(); st.push(nCr(n,r)); continue; }
        if(fn === 'nPr'){ const r = st.pop(); const n = st.pop(); st.push(nPr(n,r)); continue; }
        throw new Error('Unknown function ' + fn);
      }
    }
    if(st.length !== 1) throw new Error('Bad expression');
    return st[0];
  }

  // math helpers
  function factorial(n){ if(n<0) return NaN; if(Math.abs(n-Math.round(n))>1e-12) return gamma(n+1); n=Math.round(n); let r=1; for(let i=2;i<=n;i++) r*=i; return r; }
  function gamma(z){ const p=[0.99999999999980993,676.5203681218851,-1259.1392167224028,771.32342877765313,-176.61502916214059,12.507343278686905,-0.13857109526572012,9.9843695780195716e-6,1.5056327351493116e-7]; if(z<0.5) return Math.PI/(Math.sin(Math.PI*z)*gamma(1-z)); z-=1; let x=p[0]; for(let i=1;i<p.length;i++) x+=p[i]/(z+i); const t=z+p.length-0.5; return Math.sqrt(2*Math.PI)*Math.pow(t,z+0.5)*Math.exp(-t)*x; }
  function nCr(n,r){ n=Math.round(n); r=Math.round(r); if(r<0||r>n) return 0; return factorial(n)/(factorial(r)*factorial(n-r)); }
  function nPr(n,r){ n=Math.round(n); r=Math.round(r); if(r<0||r>n) return 0; return factorial(n)/factorial(n-r); }
  function applyTrig(name,x){ const convIn = v => (DEG ? v*Math.PI/180 : v); const convOut = v => (DEG ? v*180/Math.PI : v); switch(name){ case 'sin': return Math.sin(convIn(x)); case 'cos': return Math.cos(convIn(x)); case 'tan': return Math.tan(convIn(x)); case 'asin': return convOut(Math.asin(x)); case 'acos': return convOut(Math.acos(x)); case 'atan': return convOut(Math.atan(x)); case 'sinh': return Math.sinh?Math.sinh(x):(Math.exp(x)-Math.exp(-x))/2; case 'cosh': return Math.cosh?Math.cosh(x):(Math.exp(x)+Math.exp(-x))/2; case 'tanh': return Math.tanh?Math.tanh(x):(Math.exp(x)-Math.exp(-x))/(Math.exp(x)+Math.exp(-x)); case 'asinh': return Math.asinh?Math.asinh(x):Math.log(x+Math.sqrt(x*x+1)); case 'acosh': return Math.acosh?Math.acosh(x):Math.log(x+Math.sqrt(x*x-1)); case 'atanh': return Math.atanh?Math.atanh(x):0.5*Math.log((1+x)/(1-x)); } return NaN; }

  // MathML render helpers (simple tokens to MathML for live display)
  function renderMathMLExpression(expr){
    const tokens = tokenize(expr);
    const m = document.createElement('math'); m.setAttribute('xmlns','http://www.w3.org/1998/Math/MathML');
    const row = document.createElement('mrow');
    tokens.forEach(t => {
      if(t.type === 'num'){ const mn = document.createElement('mn'); mn.textContent = t.value; row.appendChild(mn); }
      else if(t.type === 'id'){ const mi = document.createElement('mi'); mi.textContent = t.value; row.appendChild(mi); }
      else if(t.type === 'op'){ const mo = document.createElement('mo'); mo.textContent = t.value; row.appendChild(mo); }
      else if(t.type === 'paren'){ const mo = document.createElement('mo'); mo.textContent = t.value; row.appendChild(mo); }
      else if(t.type === 'comma'){ const mo = document.createElement('mo'); mo.textContent = ','; row.appendChild(mo); }
    });
    m.appendChild(row); return m;
  }
  function renderMathMLResult(value){
    const m = document.createElement('math'); m.setAttribute('xmlns','http://www.w3.org/1998/Math/MathML');
    if(Number.isFinite(value)){ const mn = document.createElement('mn'); mn.textContent = (Math.abs(value) < 1e-12 ? 0 : +value.toPrecision(12)); m.appendChild(mn); }
    else { const mt = document.createElement('mtext'); mt.textContent = 'Error'; m.appendChild(mt); }
    return m;
  }

  // full evaluation helper
  function evaluateExpression(expr, vars = {}){
    if(!expr || expr.trim()==='') return {ok:false, error:'empty'};
    try{ const tokens = tokenize(expr); const rpn = toRPN(tokens); const value = evalRPN(rpn, vars); return {ok:true, value, rpn}; } catch(e){ return {ok:false, error: e.message}; }
  }

  // expression -> AST -> LaTeX (public)
  function expressionToLatexAST(expr){
    const tokens = tokenize(expr); const rpn = toRPN(tokens); const ast = rpnToAST(rpn); return astToLatex(ast);
  }

  // UI update
  function updateDisplays(){
    exprMath.innerHTML = ''; exprMath.appendChild(renderMathMLExpression(expression || ''));
    if(window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([exprMath, ansMath, resultLine]).catch(()=>{});
    const res = evaluateExpression(expression);
    if(res.ok){
      resultLine.innerHTML = ''; resultLine.appendChild(renderMathMLResult(res.value));
      lastAns = res.value;
      ansMath.innerHTML = ''; ansMath.appendChild(renderMathMLResult(lastAns));
      if(window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([ansMath, resultLine]).catch(()=>{});
    } else {
      resultLine.textContent = res.error === 'empty' ? '' : 'Error';
    }
  }

  function insertText(s){ expression += s; updateDisplays(); }

  // buttons
  buttons.addEventListener('click', (ev) => {
    const btn = ev.target.closest('button'); if(!btn) return;
    if(btn.id === 'equals' || btn.textContent === '='){ doEquals(); return; }
    if(btn.id === 'clear'){ expression = ''; updateDisplays(); return; }
    if(btn.id === 'back'){ expression = expression.slice(0, -1); updateDisplays(); return; }
    if(btn.id === 'mplus'){ memory += lastAns; return; }
    if(btn.id === 'mminus'){ memory -= lastAns; return; }
    if(btn.id === 'mr'){ insertText(String(memory)); return; }
    if(btn.id === 'mc'){ memory = 0; return; }
    if(btn.id === 'ansBtn'){ insertText('Ans'); return; }
    const ins = btn.dataset.insert; if(ins !== undefined) insertText(ins);
    updateDisplays();
  });

  function doEquals(){
    const res = evaluateExpression(expression);
    if(res.ok){ addHistory(expression, res.value); expression = String(res.value); updateDisplays(); }
    else { resultLine.textContent = 'Error: ' + res.error; setTimeout(()=> updateDisplays(), 1000); }
  }

  function addHistory(expr, result){
    const id = Date.now().toString(36) + Math.random().toString(36).slice(2,6);
    history.unshift({id, expr, result, time: new Date()});
    renderHistory();
  }
  function renderHistory(){
    historyList.innerHTML = '';
    history.forEach(item => {
      const div = document.createElement('div'); div.className = 'hist-item';
      const main = document.createElement('div'); main.className = 'hist-main';
      const exprSpan = document.createElement('div'); exprSpan.className='hist-expression'; exprSpan.textContent = item.expr;
      const resSpan = document.createElement('div'); resSpan.className='hist-result'; resSpan.textContent = String(item.result);
      main.appendChild(exprSpan); main.appendChild(resSpan);
      const actions = document.createElement('div'); actions.className='hist-actions';
      const useBtn = document.createElement('button'); useBtn.className='btn-ghost small'; useBtn.textContent = 'Use'; useBtn.onclick = () => { expression = item.expr; updateDisplays(); };
      const latexBtn = document.createElement('button'); latexBtn.className='btn-ghost small'; latexBtn.textContent='Copy LaTeX'; latexBtn.onclick = () => { const latex = toLatexFullAST(item.expr, item.result); navigator.clipboard.writeText(latex).then(()=> alert('LaTeX copied')); };
      const delBtn = document.createElement('button'); delBtn.className='btn-ghost small'; delBtn.textContent='Del'; delBtn.onclick = () => { const idx = history.findIndex(h => h.id === item.id); if(idx>=0){ history.splice(idx,1); renderHistory(); } };
      actions.appendChild(useBtn); actions.appendChild(latexBtn); actions.appendChild(delBtn);
      div.appendChild(main); div.appendChild(actions); historyList.appendChild(div);
    });
  }

  function toLatexFullAST(expr, result){
    try { const latexExpr = expressionToLatexAST(expr); return `\\\\displaystyle ${latexExpr} = ${String(result)}`; } catch(e) { return `\\\\text{Error converting to LaTeX}`; }
  }

  document.getElementById('copyExpr').addEventListener('click', () => {
    try { const latex = expressionToLatexAST(expression); navigator.clipboard.writeText(latex).then(()=> alert('Expression LaTeX copied')); } catch(e){ alert('Cannot convert expression to LaTeX: ' + e.message); }
  });
  document.getElementById('copyResult').addEventListener('click', () => {
    const res = evaluateExpression(expression);
    if(res.ok){ const latex = toLatexFullAST(expression, res.value); navigator.clipboard.writeText(latex).then(()=> alert('Result LaTeX copied')); } else alert('Invalid expression');
  });
  document.getElementById('clearHistory').addEventListener('click', ()=> { history.length = 0; renderHistory(); });

  // deg/rad
  degBtn.addEventListener('click', ()=>{ DEG = true; degBtn.classList.add('active'); radBtn.classList.remove('active'); modeLabel.textContent='DEG'; updateDisplays(); });
  radBtn.addEventListener('click', ()=>{ DEG = false; radBtn.classList.add('active'); degBtn.classList.remove('active'); modeLabel.textContent='RAD'; updateDisplays(); });

  // keyboard
  document.addEventListener('keydown', (e) => {
    const key = e.key;
    if(/[0-9]/.test(key)) { insertText(key); return; }
    if(key === '.') { insertText('.'); return; }
    if(key === 'Enter') { doEquals(); return; }
    if(key === 'Backspace') { expression = expression.slice(0, -1); updateDisplays(); return; }
    if(key === 'Escape') { expression = ''; updateDisplays(); return; }
    if(['+','-','*','/','^','(',')'].includes(key)) { insertText(key); return; }
    // Ctrl shortcuts
    if(e.ctrlKey && key.toLowerCase() === 'l'){ insertText('ln('); e.preventDefault(); return; }
    if(e.ctrlKey && key.toLowerCase() === 'g'){ insertText('log10('); e.preventDefault(); return; }
    if(e.ctrlKey && key.toLowerCase() === 's'){ insertText('sin('); e.preventDefault(); return; }
  });

  // Grapher
  function plotExpression(expr, xmin, xmax, samples, yscale){
    const canvas = graphCanvas; const ctx = canvas.getContext('2d');
    const DPR = window.devicePixelRatio || 1; canvas.width = canvas.clientWidth * DPR; canvas.height = canvas.clientHeight * DPR; ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight); ctx.fillStyle = '#071322'; ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
    const w = canvas.clientWidth, h = canvas.clientHeight;
    // evaluate
    const xs = [], ys = []; const step = (xmax - xmin) / Math.max(2, samples-1);
    let minY = Infinity, maxY = -Infinity;
    const tokens = tokenize(expr); const rpn = toRPN(tokens);
    for(let i=0;i<samples;i++){
      const x = xmin + i*step;
      try { const y = evalRPN(rpn, {x}); if(Number.isFinite(y)){ xs.push(x); ys.push(y); minY=Math.min(minY,y); maxY=Math.max(maxY,y); } else { xs.push(x); ys.push(NaN); } } catch(e){ xs.push(x); ys.push(NaN); }
    }
    if(minY === Infinity || maxY === -Infinity){ minY = -1; maxY = 1; }
    const padding = (maxY - minY) * 0.12 || 1; minY -= padding; maxY += padding;
    // scaling
    const ymid = (minY + maxY) / 2; const yhalf = (maxY - minY)/2 / Math.max(1, yscale);
    const toCanvasX = x => ((x - xmin) / (xmax - xmin)) * w;
    const toCanvasY = y => (1 - ((y - (ymid - yhalf)) / (2*yhalf))) * h;
    // axes
    ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1.2; ctx.beginPath();
    if(0 >= xmin && 0 <= xmax){ const x0 = toCanvasX(0); ctx.moveTo(x0,0); ctx.lineTo(x0,h); }
    if(minY <= 0 && maxY >= 0){ const y0 = toCanvasY(0); ctx.moveTo(0,y0); ctx.lineTo(w,y0); }
    ctx.stroke();
    // curve
    ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 2; ctx.beginPath();
    let started = false;
    for(let i=0;i<xs.length;i++){
      const xv = xs[i], yv = ys[i];
      if(Number.isFinite(yv)){
        const cx = toCanvasX(xv), cy = toCanvasY(yv);
        if(!started){ ctx.moveTo(cx,cy); started=true; } else ctx.lineTo(cx,cy);
      } else { started=false; }
    }
    ctx.stroke();
    // labels
    ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.font = '12px system-ui';
    ctx.fillText('x ∈ ['+xmin+','+xmax+']', 8, 16);
    ctx.fillText('y ∈ ['+minY.toFixed(3)+','+maxY.toFixed(3)+']', 8, 34);
  }

  plotBtn.addEventListener('click', () => {
    const expr = graphExpr.value.trim(); if(!expr){ alert('Enter an expression of x'); return; }
    const xmin = parseFloat(xminEl.value); const xmax = parseFloat(xmaxEl.value);
    const samples = parseInt(samplesEl.value) || 400; const yscale = parseFloat(yscaleEl.value) || 1;
    try { plotExpression(expr, xmin, xmax, samples, yscale); } catch(e){ alert('Plot error: ' + e.message); }
  });

  // tabs
  calcTab.addEventListener('click', ()=>{ calcTab.classList.add('active'); graphTab.classList.remove('active'); calcArea.style.display='block'; graphArea.style.display='none'; });
  graphTab.addEventListener('click', ()=>{ graphTab.classList.add('active'); calcTab.classList.remove('active'); calcArea.style.display='none'; graphArea.style.display='block'; graphExpr.value = expression || graphExpr.value; });

  // initial
  updateDisplays();

  // expose for debugging
  window.calc = { tokenize, toRPN, rpnToAST, astToLatex, evaluateExpression, expressionToLatexAST };

})();
</script>
</body>
</html>
