<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive C++ Master Guide - From Beginner to Expert</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --background-color: #f8f9fa;
            --text-color: #2c3e50;
            --code-bg: #2d3748;
            --code-text: #e2e8f0;
            --sidebar-bg: #34495e;
            --sidebar-text: #ecf0f1;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        .sidebar {
            width: 300px;
            background-color: var(--sidebar-bg);
            color: var(--sidebar-text);
            padding: 20px;
            overflow-y: auto;
            position: fixed;
            height: 100vh;
            left: 0;
            top: 0;
        }

        .sidebar h2 {
            margin-bottom: 20px;
            color: #fff;
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 10px;
        }

        .sidebar ul {
            list-style: none;
        }

        .sidebar li {
            margin-bottom: 10px;
        }

        .sidebar a {
            color: var(--sidebar-text);
            text-decoration: none;
            padding: 8px 12px;
            display: block;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        .sidebar a:hover {
            background-color: var(--secondary-color);
        }

        .main-content {
            margin-left: 300px;
            padding: 20px;
            flex: 1;
            max-width: 1200px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 0;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-radius: 10px;
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .module {
            background: white;
            margin-bottom: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .module-header {
            background: var(--primary-color);
            color: white;
            padding: 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .module-header h2 {
            margin: 0;
            font-size: 1.5em;
        }

        .module-header .toggle {
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .module-header.active .toggle {
            transform: rotate(180deg);
        }

        .module-content {
            padding: 20px;
            display: none;
        }

        .module-content.active {
            display: block;
        }

        .topic {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid var(--secondary-color);
        }

        .topic h3 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .code-block {
            background: var(--code-bg);
            color: var(--code-text);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
        }

        .code-block pre {
            margin: 0;
        }

        .example {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid var(--secondary-color);
        }

        .example h4 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .note {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .note h4 {
            color: #856404;
            margin-bottom: 5px;
        }

        .warning {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .warning h4 {
            color: #721c24;
            margin-bottom: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--secondary-color);
            transition: width 0.3s ease;
        }

        .difficulty {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 10px;
        }

        .difficulty.beginner {
            background: #d4edda;
            color: #155724;
        }

        .difficulty.intermediate {
            background: #fff3cd;
            color: #856404;
        }

        .difficulty.advanced {
            background: #f8d7da;
            color: #721c24;
        }

        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }

        .nav-btn {
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            transition: background-color 0.3s;
        }

        .nav-btn:hover {
            background: var(--primary-color);
        }

        .nav-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                position: relative;
                height: auto;
            }

            .main-content {
                margin-left: 0;
            }

            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="sidebar">
            <h2>C++ Learning Path</h2>
            <ul>
                <li><a href="#module1">Module 1: C++ Fundamentals</a></li>
                <li><a href="#module2">Module 2: Data Types & Variables</a></li>
                <li><a href="#module3">Module 3: Operators & Expressions</a></li>
                <li><a href="#module4">Module 4: Control Structures</a></li>
                <li><a href="#module5">Module 5: Functions</a></li>
                <li><a href="#module6">Module 6: Arrays & Strings</a></li>
                <li><a href="#module7">Module 7: Pointers & References</a></li>
                <li><a href="#module8">Module 8: Dynamic Memory</a></li>
                <li><a href="#module9">Module 9: Structures & Classes</a></li>
                <li><a href="#module10">Module 10: OOP</a></li>
                <li><a href="#module11">Module 11: Templates</a></li>
                <li><a href="#module12">Module 12: STL</a></li>
                <li><a href="#module13">Module 13: Advanced Memory</a></li>
                <li><a href="#module14">Module 14: Concurrency</a></li>
                <li><a href="#module15">Module 15: Exceptions</a></li>
                <li><a href="#module16">Module 16: File I/O</a></li>
                <li><a href="#module17">Module 17: Preprocessor</a></li>
                <li><a href="#module18">Module 18: Modern C++</a></li>
                <li><a href="#module19">Module 19: Best Practices</a></li>
                <li><a href="#module20">Module 20: Debugging</a></li>
                <li><a href="#module21">Module 21: Interfacing</a></li>
                <li><a href="#module22">Module 22: Advanced Topics</a></li>
                <li><a href="#module23">Module 23: Project Dev</a></li>
            </ul>
        </nav>

        <main class="main-content">
            <div class="header">
                <h1>Comprehensive C++ Master Guide</h1>
                <p>From Beginner to Expert - Complete C++ Programming Course</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar" style="width: 0%"></div>
                </div>
                <p>Learning Progress: <span id="progressText">0%</span></p>
            </div>

            <!-- Module 1: C++ Fundamentals -->
            <div class="module" id="module1">
                <div class="module-header" onclick="toggleModule(this)">
                    <h2>Module 1: C++ Fundamentals <span class="difficulty beginner">Beginner</span></h2>
                    <span class="toggle">â–¼</span>
                </div>
                <div class="module-content">
                    <div class="topic">
                        <h3>1.1 Introduction to C++</h3>
                        <p>C++ is a general-purpose programming language created by Bjarne Stroustrup as an extension of the C programming language. It has evolved significantly over the years, with major standards including C++98, C++11, C++14, C++17, C++20, and C++23.</p>
                        
                        <div class="example">
                            <h4>First C++ Program</h4>
                            <div class="code-block">
                                <pre>#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;
    return 0;
}</pre>
                            </div>
                        </div>

                        <div class="note">
                            <h4>Key Points:</h4>
                            <ul>
                                <li>C++ supports procedural, object-oriented, and generic programming</li>
                                <li>It provides low-level memory manipulation capabilities</li>
                                <li>Widely used in system programming, game development, and high-performance applications</li>
                            </ul>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>1.2 Basic Program Structure</h3>
                        <p>A C++ program consists of functions, with the <code>main()</code> function being the entry point. Programs are organized into header files (.h/.hpp) and source files (.cpp).</p>
                        
                        <div class="code-block">
                            <pre>// Header file: myprogram.h
#ifndef MYPROGRAM_H
#define MYPROGRAM_H

void greet();

#endif

// Source file: myprogram.cpp
#include "myprogram.h"
#include &lt;iostream&gt;

void greet() {
    std::cout &lt;&lt; "Welcome to C++!" &lt;&lt; std::endl;
}

int main() {
    greet();
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>1.3 Basic Input/Output</h3>
                        <p>C++ uses streams for input and output operations. The <code>&lt;iostream&gt;</code> library provides the basic I/O functionality.</p>
                        
                        <div class="code-block">
                            <pre>#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    std::string name;
    int age;
    
    std::cout &lt;&lt; "Enter your name: ";
    std::getline(std::cin, name);
    
    std::cout &lt;&lt; "Enter your age: ";
    std::cin &gt;&gt; age;
    
    std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "! You are " &lt;&lt; age &lt;&lt; " years old." &lt;&lt; std::endl;
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>1.4 Compilation Process</h3>
                        <p>C++ code goes through several stages: preprocessing, compilation, and linking. Understanding this process helps in debugging and optimization.</p>
                        
                        <div class="example">
                            <h4>Compilation Commands</h4>
                            <div class="code-block">
                                <pre>// Compile with g++
g++ -o program program.cpp

// Compile with optimization
g++ -O2 -o program program.cpp

// Compile with debug symbols
g++ -g -o program program.cpp

// Compile with C++20 standard
g++ -std=c++20 -o program program.cpp</pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 2: Data Types & Variables -->
            <div class="module" id="module2">
                <div class="module-header" onclick="toggleModule(this)">
                    <h2>Module 2: Data Types & Variables <span class="difficulty beginner">Beginner</span></h2>
                    <span class="toggle">â–¼</span>
                </div>
                <div class="module-content">
                    <div class="topic">
                        <h3>2.1 Fundamental Data Types</h3>
                        <p>C++ provides several built-in data types to store different kinds of values:</p>
                        
                        <div class="code-block">
                            <pre>// Integer types
int integer_var = 42;
short short_var = 10;
long long_var = 100000L;
long long long_long_var = 10000000000LL;

// Floating-point types
float float_var = 3.14f;
double double_var = 3.14159265359;
long double long_double_var = 3.14159265358979323846L;

// Character types
char char_var = 'A';
wchar_t wchar_var = L'Î©';
char16_t char16_var = u'Ã±';
char32_t char32_var = U'ðŸ˜Š';

// Boolean type
bool bool_var = true;</pre>
                        </div>

                        <div class="note">
                            <h4>Type Sizes (typically):</h4>
                            <ul>
                                <li>char: 1 byte</li>
                                <li>short: 2 bytes</li>
                                <li>int: 4 bytes</li>
                                <li>long: 4 or 8 bytes</li>
                                <li>long long: 8 bytes</li>
                                <li>float: 4 bytes</li>
                                <li>double: 8 bytes</li>
                                <li>long double: 8, 12, or 16 bytes</li>
                            </ul>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>2.2 Variables and Storage</h3>
                        <p>Variables are named storage locations. C++ provides various storage classes that determine the scope and lifetime of variables.</p>
                        
                        <div class="code-block">
                            <pre>// Global variable (static storage duration)
int global_var = 100;

void function() {
    // Local variable (automatic storage duration)
    int local_var = 50;
    
    // Static local variable (static storage duration)
    static int static_var = 25;
    
    // Register variable (hint to compiler)
    register int register_var = 10;
    
    // Thread-local variable (thread storage duration)
    thread_local int thread_var = 5;
}

// External variable declaration
extern int external_var;</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>2.3 Type Deduction</h3>
                        <p>Modern C++ provides ways to let the compiler deduce types automatically, making code more concise and maintainable.</p>
                        
                        <div class="code-block">
                            <pre>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;typeinfo&gt;

int main() {
    // Auto type deduction
    auto x = 42;           // int
    auto y = 3.14;         // double
    auto z = "Hello";      // const char*
    
    // Decltype
    int a = 10;
    decltype(a) b = 20;    // b is int
    
    // Sizeof operator
    std::cout &lt;&lt; "Size of int: " &lt;&lt; sizeof(int) &lt;&lt; " bytes" &lt;&lt; std::endl;
    
    // Type aliases
    using Integer = int;
    using StringVector = std::vector&lt;std::string&gt;;
    
    Integer num = 100;
    StringVector names = {"Alice", "Bob", "Charlie"};
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>2.4 Constants and Enumerations</h3>
                        <p>Constants provide ways to define values that cannot be changed, while enumerations create named sets of integer constants.</p>
                        
                        <div class="code-block">
                            <pre>// Const variables
const int MAX_SIZE = 100;
const double PI = 3.14159265359;

// Constexpr (compile-time constants)
constexpr int ARRAY_SIZE = 10;
constexpr double SQUARE(double x) { return x * x; }

// Traditional enum
enum Color {
    RED,
    GREEN,
    BLUE
};

// Enum class (scoped enum)
enum class Direction {
    NORTH,
    SOUTH,
    EAST,
    WEST
};

int main() {
    Color c = RED;
    Direction d = Direction::NORTH;
    
    // Compile-time computation
    constexpr double area = SQUARE(5.0);
    
    return 0;
}</pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 3: Operators & Expressions -->
            <div class="module" id="module3">
                <div class="module-header" onclick="toggleModule(this)">
                    <h2>Module 3: Operators & Expressions <span class="difficulty beginner">Beginner</span></h2>
                    <span class="toggle">â–¼</span>
                </div>
                <div class="module-content">
                    <div class="topic">
                        <h3>3.1 Arithmetic Operators</h3>
                        <p>Arithmetic operators perform mathematical calculations on operands.</p>
                        
                        <div class="code-block">
                            <pre>#include &lt;iostream&gt;

int main() {
    int a = 10, b = 3;
    
    // Basic arithmetic
    std::cout &lt;&lt; "a + b = " &lt;&lt; a + b &lt;&lt; std::endl;  // 13
    std::cout &lt;&lt; "a - b = " &lt;&lt; a - b &lt;&lt; std::endl;  // 7
    std::cout &lt;&lt; "a * b = " &lt;&lt; a * b &lt;&lt; std::endl;  // 30
    std::cout &lt;&lt; "a / b = " &lt;&lt; a / b &lt;&lt; std::endl;  // 3 (integer division)
    std::cout &lt;&lt; "a % b = " &lt;&lt; a % b &lt;&lt; std::endl;  // 1 (modulo)
    
    // Unary operators
    std::cout &lt;&lt; "+a = " &lt;&lt; +a &lt;&lt; std::endl;        // 10
    std::cout &lt;&lt; "-a = " &lt;&lt; -a &lt;&lt; std::endl;        // -10
    
    // Increment and decrement
    int x = 5;
    std::cout &lt;&lt; "x++ = " &lt;&lt; x++ &lt;&lt; std::endl;    // 5 (post-increment)
    std::cout &lt;&lt; "++x = " &lt;&lt; ++x &lt;&lt; std::endl;    // 7 (pre-increment)
    std::cout &lt;&lt; "x-- = " &lt;&lt; x-- &lt;&lt; std::endl;    // 7 (post-decrement)
    std::cout &lt;&lt; "--x = " &lt;&lt; --x &lt;&lt; std::endl;    // 5 (pre-decrement)
    
    // Compound assignment
    x += 3;  // x = x + 3
    x -= 2;  // x = x - 2
    x *= 4;  // x = x * 4
    x /= 2;  // x = x / 2
    x %= 3;  // x = x % 3
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>3.2 Comparison & Logical Operators</h3>
                        <p>Comparison operators compare values and return boolean results, while logical operators combine boolean expressions.</p>
                        
                        <div class="code-block">
                            <pre>#include &lt;iostream&gt;

int main() {
    int a = 10, b = 20, c = 10;
    
    // Comparison operators
    std::cout &lt;&lt; "a == b: " &lt;&lt; (a == b) &lt;&lt; std::endl;  // false
    std::cout &lt;&lt; "a != b: " &lt;&lt; (a != b) &lt;&lt; std::endl;  // true
    std::cout &lt;&lt; "a < b: " &lt;&lt; (a < b) &lt;&lt; std::endl;    // true
    std::cout &lt;&lt; "a > b: " &lt;&lt; (a > b) &lt;&lt; std::endl;    // false
    std::cout &lt;&lt; "a <= c: " &lt;&lt; (a <= c) &lt;&lt; std::endl;  // true
    std::cout &lt;&lt; "a >= c: " &lt;&lt; (a >= c) &lt;&lt; std::endl;  // true
    
    // Logical operators
    bool p = true, q = false;
    
    std::cout &lt;&lt; "p && q: " &lt;&lt; (p && q) &lt;&lt; std::endl;  // false (AND)
    std::cout &lt;&lt; "p || q: " &lt;&lt; (p || q) &lt;&lt; std::endl;  // true (OR)
    std::cout &lt;&lt; "!p: " &lt;&lt; !p &lt;&lt; std::endl;            // false (NOT)
    
    // Short-circuit evaluation
    int x = 5, y = 0;
    bool result = (y != 0) && (x / y > 2);  // Safe due to short-circuit
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>3.3 Bitwise Operators</h3>
                        <p>Bitwise operators work on the binary representation of integers, useful for low-level programming and optimization.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;

int main() {
    unsigned int a = 60;  // 0011 1100
    unsigned int b = 13;  // 0000 1101
    
    // Bitwise AND
    std::cout &lt;&lt; "a & b = " &lt;&lt; (a & b) &lt;&lt; std::endl;  // 12 (0000 1100)
    
    // Bitwise OR
    std::cout &lt;&lt; "a | b = " &lt;&lt; (a | b) &lt;&lt; std::endl;  // 61 (0011 1101)
    
    // Bitwise XOR
    std::cout &lt;&lt; "a ^ b = " &lt;&lt; (a ^ b) &lt;&lt; std::endl;  // 49 (0011 0001)
    
    // Bitwise NOT
    std::cout &lt;&lt; "~a = " &lt;&lt; (~a) &lt;&lt; std::endl;      // -61 (1100 0011)
    
    // Left shift
    std::cout &lt;&lt; "a << 2 = " &lt;&lt; (a << 2) &lt;&lt; std::endl;  // 240 (1111 0000)
    
    // Right shift
    std::cout &lt;&lt; "a >> 2 = " &lt;&lt; (a >> 2) &lt;&lt; std::endl;  // 15 (0000 1111)
    
    // Bitwise assignment
    a &= b;   // a = a & b
    a |= b;   // a = a | b
    a ^= b;   // a = a ^ b
    a <<= 2;  // a = a << 2
    a >>= 2;  // a = a >> 2
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>3.4 Advanced Operators</h3>
                        <p>C++ provides several advanced operators for special purposes.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;
#include &lt;string&gt;

class MyClass {
public:
    int value;
    MyClass(int v) : value(v) {}
};

int main() {
    // Conditional operator (ternary)
    int x = 10, y = 20;
    int max = (x > y) ? x : y;
    std::cout &lt;&lt; "Max: " &lt;&lt; max &lt;&lt; std::endl;
    
    // Comma operator
    int a = (1, 2, 3, 4, 5);  // a = 5 (last expression)
    std::cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; std::endl;
    
    // Member access operators
    MyClass obj(42);
    std::cout &lt;&lt; "obj.value: " &lt;&lt; obj.value &lt;&lt; std::endl;
    
    MyClass* ptr = &obj;
    std::cout &lt;&lt; "ptr->value: " &lt;&lt; ptr->value &lt;&lt; std::endl;
    
    // Sizeof and alignof
    std::cout &lt;&lt; "Size of int: " &lt;&lt; sizeof(int) &lt;&lt; std::endl;
    std::cout &lt;&lt; "Alignment of int: " &lt;&lt; alignof(int) &lt;&lt; std::endl;
    
    // Scope resolution
    int value = 100;
    std::cout &lt;&lt; "Local value: " &lt;&lt; value &lt;&lt; std::endl;
    std::cout &lt;&lt; "Global value: " &lt;&lt; ::value &lt;&lt; std::endl;
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>3.5 Operator Precedence & Associativity</h3>
                        <p>Understanding operator precedence is crucial for writing correct expressions.</p>
                        
                        <div class="note">
                            <h4>Operator Precedence (Highest to Lowest):</h4>
                            <ol>
                                <li>Scope resolution <code>::</code></li>
                                <li>Member access <code>. -></code>, postfix <code>++ --</code></li>
                                <li>Prefix <code>++ --</code>, unary <code>+ - ! ~</code>, sizeof, new/delete, cast</li>
                                <li>Pointer-to-member <code>.* ->*</code></li>
                                <li>Multiplication <code>* / %</code></li>
                                <li>Addition <code>+ -</code></li>
                                <li>Shift <code><< >></code></li>
                                <li>Relational <code>< <= > >=</code></li>
                                <li>Equality <code>== !=</code></li>
                                <li>Bitwise AND <code>&</code></li>
                                <li>Bitwise XOR <code>^</code></li>
                                <li>Bitwise OR <code>|</code></li>
                                <li>Logical AND <code>&&</code></li>
                                <li>Logical OR <code>||</code></li>
                                <li>Conditional <code>?:</code></li>
                                <li>Assignment <code>= += -= *= /= %= &= |= ^= <<= >>=</code></li>
                                <li>Comma <code>,</code></li>
                            </ol>
                        </div>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;

int main() {
    // Example of precedence importance
    int result = 5 + 3 * 2;      // 11 (multiplication first)
    int result2 = (5 + 3) * 2;   // 16 (parentheses first)
    
    // Associativity example
    int x = 10, y = 5, z = 2;
    int result3 = x - y - z;     // 3 (left associativity)
    int result4 = x - (y - z);   // 7 (explicit grouping)
    
    std::cout &lt;&lt; "5 + 3 * 2 = " &lt;&lt; result &lt;&lt; std::endl;
    std::cout &lt;&lt; "(5 + 3) * 2 = " &lt;&lt; result2 &lt;&lt; std::endl;
    std::cout &lt;&lt; "10 - 5 - 2 = " &lt;&lt; result3 &lt;&lt; std::endl;
    std::cout &lt;&lt; "10 - (5 - 2) = " &lt;&lt; result4 &lt;&lt; std::endl;
    
    return 0;
}</pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 4: Control Structures -->
            <div class="module" id="module4">
                <div class="module-header" onclick="toggleModule(this)">
                    <h2>Module 4: Control Structures <span class="difficulty beginner">Beginner</span></h2>
                    <span class="toggle">â–¼</span>
                </div>
                <div class="module-content">
                    <div class="topic">
                        <h3>4.1 Conditional Statements</h3>
                        <p>Conditional statements allow programs to make decisions and execute different code based on conditions.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;

int main() {
    int age;
    std::cout &lt;&lt; "Enter your age: ";
    std::cin &gt;&gt; age;
    
    // if-else statement
    if (age >= 18) {
        std::cout &lt;&lt; "You are an adult." &lt;&lt; std::endl;
    } else if (age >= 13) {
        std::cout &lt;&lt; "You are a teenager." &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "You are a child." &lt;&lt; std::endl;
    }
    
    // Nested if-else
    if (age >= 18) {
        if (age >= 65) {
            std::cout &lt;&lt; "You are a senior citizen." &lt;&lt; std::endl;
        } else {
            std::cout &lt;&lt; "You are a working adult." &lt;&lt; std::endl;
        }
    }
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>4.2 Switch Statements</h3>
                        <p>Switch statements provide a cleaner way to handle multiple conditions based on a single value.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;

int main() {
    char grade;
    std::cout &lt;&lt; "Enter your grade (A-F): ";
    std::cin &gt;&gt; grade;
    
    switch (grade) {
        case 'A':
        case 'a':
            std::cout &lt;&lt; "Excellent!" &lt;&lt; std::endl;
            break;
        case 'B':
        case 'b':
            std::cout &lt;&lt; "Good!" &lt;&lt; std::endl;
            break;
        case 'C':
        case 'c':
            std::cout &lt;&lt; "Average." &lt;&lt; std::endl;
            break;
        case 'D':
        case 'd':
            std::cout &lt;&lt; "Below average." &lt;&lt; std::endl;
            break;
        case 'F':
        case 'f':
            std::cout &lt;&lt; "Fail." &lt;&lt; std::endl;
            break;
        default:
            std::cout &lt;&lt; "Invalid grade!" &lt;&lt; std::endl;
    }
    
    return 0;
}</pre>
                        </div>
                        
                        <div class="warning">
                            <h4>Important:</h4>
                            <p>Don't forget the <code>break</code> statement in each case, or execution will "fall through" to the next case. This can be intentional but is often a source of bugs.</p>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>4.3 Looping Constructs</h3>
                        <p>Loops allow you to execute code repeatedly based on conditions.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    // While loop
    int count = 1;
    while (count <= 5) {
        std::cout &lt;&lt; "While loop: " &lt;&lt; count &lt;&lt; std::endl;
        count++;
    }
    
    // Do-while loop
    int num = 1;
    do {
        std::cout &lt;&lt; "Do-while loop: " &lt;&lt; num &lt;&lt; std::endl;
        num++;
    } while (num <= 3);
    
    // For loop
    for (int i = 1; i <= 5; i++) {
        std::cout &lt;&lt; "For loop: " &lt;&lt; i &lt;&lt; std::endl;
    }
    
    // Range-based for loop (C++11)
    std::vector&lt;std::string&gt; fruits = {"Apple", "Banana", "Cherry"};
    for (const auto& fruit : fruits) {
        std::cout &lt;&lt; "Fruit: " &lt;&lt; fruit &lt;&lt; std::endl;
    }
    
    // Nested loops
    for (int i = 1; i <= 3; i++) {
        for (int j = 1; j <= 3; j++) {
            std::cout &lt;&lt; i &lt;&lt; " * " &lt;&lt; j &lt;&lt; " = " &lt;&lt; i * j &lt;&lt; std::endl;
        }
    }
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>4.4 Jump Statements</h3>
                        <p>Jump statements allow you to transfer control unconditionally within a program.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;

int main() {
    // Break statement
    for (int i = 1; i <= 10; i++) {
        if (i == 6) {
            break;  // Exit the loop
        }
        std::cout &lt;&lt; i &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    // Continue statement
    for (int i = 1; i <= 10; i++) {
        if (i % 2 == 0) {
            continue;  // Skip even numbers
        }
        std::cout &lt;&lt; i &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    // Return statement
    auto printMessage = []() {
        std::cout &lt;&lt; "Returning from lambda" &lt;&lt; std::endl;
        return 42;  // Return value
    };
    
    int result = printMessage();
    std::cout &lt;&lt; "Result: " &lt;&lt; result &lt;&lt; std::endl;
    
    // Goto statement (use sparingly)
    int x = 0;
    start_loop:
    if (x < 3) {
        std::cout &lt;&lt; "Goto loop: " &lt;&lt; x &lt;&lt; std::endl;
        x++;
        goto start_loop;
    }
    
    return 0;
}</pre>
                        </div>
                        
                        <div class="warning">
                            <h4>Warning:</h4>
                            <p>The <code>goto</code> statement can make code difficult to read and maintain. Use it only when absolutely necessary, such as breaking out of nested loops.</p>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>4.5 Conditional Compilation</h3>
                        <p>Preprocessor directives allow you to include or exclude code based on compile-time conditions.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;

#define DEBUG_MODE
#define VERSION 2

int main() {
#ifdef DEBUG_MODE
    std::cout &lt;&lt; "Debug mode is enabled" &lt;&lt; std::endl;
#endif
    
#if VERSION == 1
    std::cout &lt;&lt; "Running version 1" &lt;&lt; std::endl;
#elif VERSION == 2
    std::cout &lt;&lt; "Running version 2" &lt;&lt; std::endl;
#else
    std::cout &lt;&lt; "Running unknown version" &lt;&lt; std::endl;
#endif
    
#ifndef NDEBUG
    std::cout &lt;&lt; "Assertions are enabled" &lt;&lt; std::endl;
#endif
    
    // Platform-specific code
#ifdef _WIN32
    std::cout &lt;&lt; "Running on Windows" &lt;&lt; std::endl;
#elif __linux__
    std::cout &lt;&lt; "Running on Linux" &lt;&lt; std::endl;
#elif __APPLE__
    std::cout &lt;&lt; "Running on macOS" &lt;&lt; std::endl;
#endif
    
    return 0;
}</pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 5: Functions -->
            <div class="module" id="module5">
                <div class="module-header" onclick="toggleModule(this)">
                    <h2>Module 5: Functions <span class="difficulty intermediate">Intermediate</span></h2>
                    <span class="toggle">â–¼</span>
                </div>
                <div class="module-content">
                    <div class="topic">
                        <h3>5.1 Function Basics</h3>
                        <p>Functions are reusable blocks of code that perform specific tasks. They help organize code and promote reusability.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;
#include &lt;string&gt;

// Function declaration (prototype)
int add(int a, int b);
void greet(const std::string& name);
double calculateAverage(double a, double b, double c);

// Function definition
int add(int a, int b) {
    return a + b;
}

void greet(const std::string& name) {
    std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!" &lt;&lt; std::endl;
}

double calculateAverage(double a, double b, double c) {
    return (a + b + c) / 3.0;
}

int main() {
    // Function calls
    int sum = add(5, 3);
    std::cout &lt;&lt; "Sum: " &lt;&lt; sum &lt;&lt; std::endl;
    
    greet("Alice");
    
    double avg = calculateAverage(10.5, 20.5, 30.5);
    std::cout &lt;&lt; "Average: " &lt;&lt; avg &lt;&lt; std::endl;
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>5.2 Parameter Passing Mechanisms</h3>
                        <p>C++ provides different ways to pass parameters to functions, each with its own advantages and use cases.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;
#include &lt;string&gt;

// Pass by value
void passByValue(int x) {
    x = 100;  // Changes only the local copy
    std::cout &lt;&lt; "Inside passByValue: " &lt;&lt; x &lt;&lt; std::endl;
}

// Pass by reference
void passByReference(int& x) {
    x = 200;  // Changes the original variable
    std::cout &lt;&lt; "Inside passByReference: " &lt;&lt; x &lt;&lt; std::endl;
}

// Pass by const reference
void passByConstReference(const std::string& str) {
    // str = "Modified";  // Error: cannot modify const reference
    std::cout &lt;&lt; "Inside passByConstReference: " &lt;&lt; str &lt;&lt; std::endl;
}

// Pass by pointer
void passByPointer(int* ptr) {
    if (ptr != nullptr) {
        *ptr = 300;  // Changes the value pointed to
        std::cout &lt;&lt; "Inside passByPointer: " &lt;&lt; *ptr &lt;&lt; std::endl;
    }
}

// Pass by rvalue reference (C++11)
void passByRvalueReference(int&& x) {
    x = 400;  // Can modify, but typically used for moving
    std::cout &lt;&lt; "Inside passByRvalueReference: " &lt;&lt; x &lt;&lt; std::endl;
}

int main() {
    int value = 50;
    std::string text = "Hello";
    
    std::cout &lt;&lt; "Before passByValue: " &lt;&lt; value &lt;&lt; std::endl;
    passByValue(value);
    std::cout &lt;&lt; "After passByValue: " &lt;&lt; value &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "\nBefore passByReference: " &lt;&lt; value &lt;&lt; std::endl;
    passByReference(value);
    std::cout &lt;&lt; "After passByReference: " &lt;&lt; value &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "\nBefore passByConstReference: " &lt;&lt; text &lt;&lt; std::endl;
    passByConstReference(text);
    std::cout &lt;&lt; "After passByConstReference: " &lt;&lt; text &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "\nBefore passByPointer: " &lt;&lt; value &lt;&lt; std::endl;
    passByPointer(&value);
    std::cout &lt;&lt; "After passByPointer: " &lt;&lt; value &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "\nBefore passByRvalueReference: " &lt;&lt; value &lt;&lt; std::endl;
    passByRvalueReference(42);  // Passing literal
    std::cout &lt;&lt; "After passByRvalueReference: " &lt;&lt; value &lt;&lt; std::endl;
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>5.3 Advanced Function Features</h3>
                        <p>C++ provides several advanced features for functions that enhance flexibility and performance.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;
#include &lt;string&gt;

// Default arguments
void printInfo(const std::string& name, int age = 25, const std::string& country = "USA") {
    std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age 
              &lt;&lt; ", Country: " &lt;&lt; country &lt;&lt; std::endl;
}

// Function overloading
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

std::string add(const std::string& a, const std::string& b) {
    return a + b;
}

// Inline function
inline int square(int x) {
    return x * x;
}

// Recursive function
int factorial(int n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

// Function pointer
int (*funcPtr)(int, int) = add;

int main() {
    // Default arguments
    printInfo("Alice");
    printInfo("Bob", 30);
    printInfo("Charlie", 35, "Canada");
    
    // Function overloading
    std::cout &lt;&lt; "Add ints: " &lt;&lt; add(5, 3) &lt;&lt; std::endl;
    std::cout &lt;&lt; "Add doubles: " &lt;&lt; add(5.5, 3.3) &lt;&lt; std::endl;
    std::cout &lt;&lt; "Add strings: " &lt;&lt; add("Hello, ", "World!") &lt;&lt; std::endl;
    
    // Inline function
    std::cout &lt;&lt; "Square of 7: " &lt;&lt; square(7) &lt;&lt; std::endl;
    
    // Recursive function
    std::cout &lt;&lt; "Factorial of 5: " &lt;&lt; factorial(5) &lt;&lt; std::endl;
    
    // Function pointer
    std::cout &lt;&lt; "Using function pointer: " &lt;&lt; funcPtr(10, 20) &lt;&lt; std::endl;
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>5.4 Modern Function Features</h3>
                        <p>Modern C++ (C++11 and later) introduces lambda expressions and other advanced function features.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;

int main() {
    // Lambda expressions
    auto simpleLambda = []() {
        std::cout &lt;&lt; "Hello from lambda!" &lt;&lt; std::endl;
    };
    
    auto lambdaWithParams = [](int a, int b) {
        return a + b;
    };
    
    int x = 10, y = 20;
    auto lambdaWithCapture = [x, y]() {
        std::cout &lt;&lt; "Captured: x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y &lt;&lt; std::endl;
    };
    
    auto lambdaWithReferenceCapture = [&x, &y]() {
        x = 100;
        y = 200;
        std::cout &lt;&lt; "Modified: x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y &lt;&lt; std::endl;
    };
    
    // Generic lambda (C++14)
    auto genericLambda = [](auto a, auto b) {
        return a + b;
    };
    
    // Lambda with mutable capture
    auto mutableLambda = [x]() mutable {
        x = 50;  // Can modify captured value
        std::cout &lt;&lt; "Mutable lambda: x = " &lt;&lt; x &lt;&lt; std::endl;
    };
    
    // Calling lambdas
    simpleLambda();
    std::cout &lt;&lt; "Lambda with params: " &lt;&lt; lambdaWithParams(5, 3) &lt;&lt; std::endl;
    lambdaWithCapture();
    std::cout &lt;&lt; "Before reference capture: x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y &lt;&lt; std::endl;
    lambdaWithReferenceCapture();
    std::cout &lt;&lt; "After reference capture: x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y &lt;&lt; std::endl;
    std::cout &lt;&lt; "Generic lambda: " &lt;&lt; genericLambda(5, 3) &lt;&lt; std::endl;
    std::cout &lt;&lt; "Generic lambda with strings: " &lt;&lt; genericLambda(std::string("Hello "), std::string("World")) &lt;&lt; std::endl;
    mutableLambda();
    
    // Using lambdas with STL algorithms
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // Using std::function
    std::function&lt;int(int)&gt; squareFunc = [](int n) { return n * n; };
    
    std::cout &lt;&lt; "Squared numbers: ";
    std::transform(numbers.begin(), numbers.end(), numbers.begin(), squareFunc);
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    // constexpr function (C++11)
    constexpr int factorialConstexpr(int n) {
        return n <= 1 ? 1 : n * factorialConstexpr(n - 1);
    }
    
    constexpr int result = factorialConstexpr(5);
    std::cout &lt;&lt; "Compile-time factorial: " &lt;&lt; result &lt;&lt; std::endl;
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>5.5 Function Best Practices</h3>
                        <p>Following best practices when working with functions ensures code quality, maintainability, and performance.</p>
                        
                        <div class="note">
                            <h4>Function Design Principles:</h4>
                            <ul>
                                <li><strong>Single Responsibility:</strong> Each function should do one thing well</li>
                                <li><strong>Short and Focused:</strong> Keep functions concise and focused</li>
                                <li><strong>Clear Naming:</strong> Use descriptive names that indicate the function's purpose</li>
                                <li><strong>Consistent Style:</strong> Follow consistent naming conventions</li>
                                <li><strong>Parameter Passing:</strong> Use const references for large objects to avoid copying</li>
                                <li><strong>Error Handling:</strong> Decide how to handle errors (exceptions, error codes, etc.)</li>
                                <li><strong>Documentation:</strong> Document function behavior, parameters, and return values</li>
                            </ul>
                        </div>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

/**
 * @brief Calculates the average of a vector of numbers
 * @param numbers Vector of double values
 * @return Average of the numbers
 * @throws std::invalid_argument if the vector is empty
 */
double calculateAverage(const std::vector&lt;double&gt;& numbers) {
    if (numbers.empty()) {
        throw std::invalid_argument("Cannot calculate average of empty vector");
    }
    
    double sum = 0.0;
    for (const auto& num : numbers) {
        sum += num;
    }
    
    return sum / numbers.size();
}

/**
 * @brief Validates if a number is within a specified range
 * @param value The number to validate
 * @param min Minimum allowed value (inclusive)
 * @param max Maximum allowed value (inclusive)
 * @return true if the number is within range, false otherwise
 */
bool isInRange(double value, double min, double max) {
    return value >= min && value <= max;
}

int main() {
    try {
        std::vector&lt;double&gt; scores = {85.5, 92.0, 78.5, 96.0, 88.5};
        double average = calculateAverage(scores);
        std::cout &lt;&lt; "Average score: " &lt;&lt; average &lt;&lt; std::endl;
        
        if (isInRange(average, 0.0, 100.0)) {
            std::cout &lt;&lt; "Average is within valid range" &lt;&lt; std::endl;
        }
        
        // This will throw an exception
        std::vector&lt;double&gt; empty;
        calculateAverage(empty);
        
    } catch (const std::invalid_argument& e) {
        std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    
    return 0;
}</pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Due to length constraints, I'll continue with the remaining modules in a more condensed format -->
            
            <!-- Module 6: Arrays & Strings -->
            <div class="module" id="module6">
                <div class="module-header" onclick="toggleModule(this)">
                    <h2>Module 6: Arrays & Strings <span class="difficulty intermediate">Intermediate</span></h2>
                    <span class="toggle">â–¼</span>
                </div>
                <div class="module-content">
                    <div class="topic">
                        <h3>6.1 Arrays</h3>
                        <p>Arrays are contiguous memory locations that store multiple values of the same type.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;

int main() {
    // Static array declaration
    int arr1[5] = {1, 2, 3, 4, 5};
    int arr2[] = {10, 20, 30, 40, 50};  // Size inferred
    
    // Accessing elements
    std::cout &lt;&lt; "First element: " &lt;&lt; arr1[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; "Third element: " &lt;&lt; arr1[2] &lt;&lt; std::endl;
    
    // Multidimensional arrays
    int matrix[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    
    // Accessing 2D array elements
    std::cout &lt;&lt; "Matrix[1][1]: " &lt;&lt; matrix[1][1] &lt;&lt; std::endl;
    
    // Array bounds
    int size = sizeof(arr1) / sizeof(arr1[0]);
    std::cout &lt;&lt; "Array size: " &lt;&lt; size &lt;&lt; std::endl;
    
    // Array iteration
    for (int i = 0; i < size; i++) {
        std::cout &lt;&lt; arr1[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>6.2 Dynamic Arrays</h3>
                        <p>Dynamic arrays are allocated on the heap and can be resized during runtime.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;

int main() {
    // Dynamic array allocation
    int size = 5;
    int* dynamicArray = new int[size];
    
    // Initialize array
    for (int i = 0; i < size; i++) {
        dynamicArray[i] = i * 10;
    }
    
    // Print array
    for (int i = 0; i < size; i++) {
        std::cout &lt;&lt; dynamicArray[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    // Resize array (create new larger array)
    int newSize = 10;
    int* newArray = new int[newSize];
    
    // Copy old elements
    for (int i = 0; i < size; i++) {
        newArray[i] = dynamicArray[i];
    }
    
    // Initialize new elements
    for (int i = size; i < newSize; i++) {
        newArray[i] = i * 10;
    }
    
    // Delete old array
    delete[] dynamicArray;
    
    // Use new array
    dynamicArray = newArray;
    size = newSize;
    
    // Print resized array
    for (int i = 0; i < size; i++) {
        std::cout &lt;&lt; dynamicArray[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    // Clean up
    delete[] dynamicArray;
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>6.3 C-style Strings</h3>
                        <p>C-style strings are null-terminated character arrays and are the foundation of string handling in C++.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;
#include &lt;cstring&gt;

int main() {
    // C-style string literals
    const char* str1 = "Hello";
    char str2[] = "World";
    
    // String operations
    std::cout &lt;&lt; "String length: " &lt;&lt; strlen(str1) &lt;&lt; std::endl;
    
    // String concatenation
    char result[50];
    strcpy(result, str1);
    strcat(result, " ");
    strcat(result, str2);
    std::cout &lt;&lt; "Concatenated: " &lt;&lt; result &lt;&lt; std::endl;
    
    // String comparison
    if (strcmp(str1, "Hello") == 0) {
        std::cout &lt;&lt; "Strings are equal" &lt;&lt; std::endl;
    }
    
    // String copying
    char copy[20];
    strncpy(copy, str1, sizeof(copy) - 1);
    copy[sizeof(copy) - 1] = '\0';  // Ensure null termination
    std::cout &lt;&lt; "Copy: " &lt;&lt; copy &lt;&lt; std::endl;
    
    // String searching
    const char* text = "The quick brown fox";
    const char* found = strstr(text, "brown");
    if (found) {
        std::cout &lt;&lt; "Found substring at position: " &lt;&lt; found - text &lt;&lt; std::endl;
    }
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>6.4 Modern String Handling</h3>
                        <p>The <code>std::string</code> class provides a safer and more convenient way to handle strings.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

int main() {
    // std::string basics
    std::string str1 = "Hello";
    std::string str2 = "World";
    
    // String concatenation
    std::string result = str1 + " " + str2;
    std::cout &lt;&lt; "Concatenated: " &lt;&lt; result &lt;&lt; std::endl;
    
    // String operations
    std::cout &lt;&lt; "Length: " &lt;&lt; result.length() &lt;&lt; std::endl;
    std::cout &lt;&lt; "Size: " &lt;&lt; result.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; "First character: " &lt;&lt; result[0] &lt;&lt; std::endl;
    std::cout &lt;&lt; "Last character: " &lt;&lt; result.back() &lt;&lt; std::endl;
    
    // Substring
    std::string substring = result.substr(0, 5);
    std::cout &lt;&lt; "Substring: " &lt;&lt; substring &lt;&lt; std::endl;
    
    // Find and replace
    size_t pos = result.find("World");
    if (pos != std::string::npos) {
        result.replace(pos, 5, "C++");
        std::cout &lt;&lt; "After replace: " &lt;&lt; result &lt;&lt; std::endl;
    }
    
    // String streams
    std::stringstream ss;
    ss &lt;&lt; "The answer is " &lt;&lt; 42;
    std::string streamResult = ss.str();
    std::cout &lt;&lt; "Stream result: " &lt;&lt; streamResult &lt;&lt; std::endl;
    
    // Parsing with string streams
    std::string data = "10 20 30 40 50";
    std::stringstream parser(data);
    int number;
    while (parser >> number) {
        std::cout &lt;&lt; "Parsed number: " &lt;&lt; number &lt;&lt; std::endl;
    }
    
    // String views (C++17)
    std::string_view view = result;
    std::cout &lt;&lt; "String view: " &lt;&lt; view &lt;&lt; std::endl;
    
    return 0;
}</pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 7: Pointers & References -->
            <div class="module" id="module7">
                <div class="module-header" onclick="toggleModule(this)">
                    <h2>Module 7: Pointers & References <span class="difficulty intermediate">Intermediate</span></h2>
                    <span class="toggle">â–¼</span>
                </div>
                <div class="module-content">
                    <div class="topic">
                        <h3>7.1 Pointer Fundamentals</h3>
                        <p>Pointers are variables that store memory addresses. They are fundamental to C++ and provide powerful capabilities.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;

int main() {
    int value = 42;
    int* ptr = &value;  // Pointer to value
    
    std::cout &lt;&lt; "Value: " &lt;&lt; value &lt;&lt; std::endl;
    std::cout &lt;&lt; "Address of value: " &lt;&lt; &value &lt;&lt; std::endl;
    std::cout &lt;&lt; "Pointer value: " &lt;&lt; ptr &lt;&lt; std::endl;
    std::cout &lt;&lt; "Dereferenced pointer: " &lt;&lt; *ptr &lt;&lt; std::endl;
    
    // Modifying through pointer
    *ptr = 100;
    std::cout &lt;&lt; "Modified value: " &lt;&lt; value &lt;&lt; std::endl;
    
    // Null pointer
    int* nullPtr = nullptr;
    if (nullPtr == nullptr) {
        std::cout &lt;&lt; "Pointer is null" &lt;&lt; std::endl;
    }
    
    // Pointer arithmetic
    int arr[] = {10, 20, 30, 40, 50};
    int* arrPtr = arr;
    
    std::cout &lt;&lt; "Array elements via pointer: ";
    for (int i = 0; i < 5; i++) {
        std::cout &lt;&lt; *(arrPtr + i) &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>7.2 Advanced Pointers</h3>
                        <p>Advanced pointer concepts including pointers to pointers, function pointers, and pointer to members.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;

class MyClass {
public:
    int value;
    MyClass(int v) : value(v) {}
    void print() { std::cout &lt;&lt; "Value: " &lt;&lt; value &lt;&lt; std::endl; }
};

// Function that takes a function pointer
void executeFunction(void (*func)(int), int value) {
    func(value);
}

void printNumber(int num) {
    std::cout &lt;&lt; "Number: " &lt;&lt; num &lt;&lt; std::endl;
}

int main() {
    // Pointer to pointer
    int value = 42;
    int* ptr = &value;
    int** ptrToPtr = &ptr;
    
    std::cout &lt;&lt; "Value via pointer to pointer: " &lt;&lt; **ptrToPtr &lt;&lt; std::endl;
    
    // Function pointer
    void (*funcPtr)(int) = printNumber;
    funcPtr(100);
    
    // Using function pointer
    executeFunction(printNumber, 200);
    
    // Pointer to member function
    MyClass obj(300);
    void (MyClass::*memberFuncPtr)() = &MyClass::print;
    (obj.*memberFuncPtr)();  // Call member function through pointer
    
    // Pointer to member data
    int MyClass::*memberDataPtr = &MyClass::value;
    std::cout &lt;&lt; "Member data via pointer: " &lt;&lt; obj.*memberDataPtr &lt;&lt; std::endl;
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>7.3 References</h3>
                        <p>References are aliases for existing variables. They provide an alternative way to access variables.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;

void modifyByReference(int& ref) {
    ref = 100;  // Modifies the original variable
}

void modifyByValue(int val) {
    val = 200;  // Only modifies the copy
}

int main() {
    int value = 42;
    int& ref = value;  // Reference to value
    
    std::cout &lt;&lt; "Original value: " &lt;&lt; value &lt;&lt; std::endl;
    ref = 50;
    std::cout &lt;&lt; "After modification via reference: " &lt;&lt; value &lt;&lt; std::endl;
    
    // Reference as function parameter
    modifyByReference(value);
    std::cout &lt;&lt; "After modifyByReference: " &lt;&lt; value &lt;&lt; std::endl;
    
    modifyByValue(value);
    std::cout &lt;&lt; "After modifyByValue: " &lt;&lt; value &lt;&lt; std::endl;
    
    // Const reference
    const int& constRef = value;
    // constRef = 150;  // Error: cannot modify const reference
    
    // Reference to array
    int arr[] = {1, 2, 3, 4, 5};
    int (&arrRef)[5] = arr;
    arrRef[0] = 10;
    std::cout &lt;&lt; "Modified array[0]: " &lt;&lt; arr[0] &lt;&lt; std::endl;
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>7.4 Smart Pointers (C++11+)</h3>
                        <p>Smart pointers are objects that manage memory automatically, preventing memory leaks and dangling pointers.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;

class Resource {
public:
    Resource() { std::cout &lt;&lt; "Resource created" &lt;&lt; std::endl; }
    ~Resource() { std::cout &lt;&lt; "Resource destroyed" &lt;&lt; std::endl; }
    void use() { std::cout &lt;&lt; "Resource used" &lt;&lt; std::endl; }
};

int main() {
    // unique_ptr - exclusive ownership
    {
        std::unique_ptr&lt;Resource&gt; uniqueRes = std::make_unique&lt;Resource&gt;();
        uniqueRes->use();
        // Resource is automatically destroyed when uniqueRes goes out of scope
    }
    
    // shared_ptr - shared ownership
    {
        std::shared_ptr&lt;Resource&gt; sharedRes1 = std::make_shared&lt;Resource&gt;();
        {
            std::shared_ptr&lt;Resource&gt; sharedRes2 = sharedRes1;
            std::cout &lt;&lt; "Use count: " &lt;&lt; sharedRes1.use_count() &lt;&lt; std::endl;
            sharedRes2->use();
        }
        std::cout &lt;&lt; "Use count after inner scope: " &lt;&lt; sharedRes1.use_count() &lt;&lt; std::endl;
    }
    
    // weak_ptr - non-owning reference
    {
        std::shared_ptr&lt;Resource&gt; sharedRes = std::make_shared&lt;Resource&gt;();
        std::weak_ptr&lt;Resource&gt; weakRes = sharedRes;
        
        if (auto locked = weakRes.lock()) {
            locked->use();
            std::cout &lt;&lt; "Weak pointer locked successfully" &lt;&lt; std::endl;
        } else {
            std::cout &lt;&lt; "Weak pointer could not be locked" &lt;&lt; std::endl;
        }
        
        sharedRes.reset();
        
        if (auto locked = weakRes.lock()) {
            locked->use();
        } else {
            std::cout &lt;&lt; "Weak pointer could not be locked after reset" &lt;&lt; std::endl;
        }
    }
    
    // Custom deleters
    {
        auto customDeleter = [](Resource* res) {
            std::cout &lt;&lt; "Custom deleter called" &lt;&lt; std::endl;
            delete res;
        };
        
        std::unique_ptr&lt;Resource, decltype(customDeleter)&gt; 
            customRes(new Resource(), customDeleter);
    }
    
    return 0;
}</pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 8: Dynamic Memory Management -->
            <div class="module" id="module8">
                <div class="module-header" onclick="toggleModule(this)">
                    <h2>Module 8: Dynamic Memory Management <span class="difficulty intermediate">Intermediate</span></h2>
                    <span class="toggle">â–¼</span>
                </div>
                <div class="module-content">
                    <div class="topic">
                        <h3>8.1 Heap Allocation</h3>
                        <p>Dynamic memory allocation allows you to request memory at runtime using the heap.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;

int main() {
    // Single object allocation
    int* ptr = new int(42);
    std::cout &lt;&lt; "Allocated value: " &lt;&lt; *ptr &lt;&lt; std::endl;
    delete ptr;
    
    // Array allocation
    int size = 5;
    int* arr = new int[size];
    
    for (int i = 0; i < size; i++) {
        arr[i] = i * 10;
    }
    
    std::cout &lt;&lt; "Array elements: ";
    for (int i = 0; i < size; i++) {
        std::cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    delete[] arr;
    
    // 2D array allocation
    int rows = 3, cols = 4;
    int** matrix = new int*[rows];
    
    for (int i = 0; i < rows; i++) {
        matrix[i] = new int[cols];
        for (int j = 0; j < cols; j++) {
            matrix[i][j] = i * cols + j;
        }
    }
    
    std::cout &lt;&lt; "2D array:" &lt;&lt; std::endl;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            std::cout &lt;&lt; matrix[i][j] &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    }
    
    // Clean up 2D array
    for (int i = 0; i < rows; i++) {
        delete[] matrix[i];
    }
    delete[] matrix;
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>8.2 C-style Memory Management</h3>
                        <p>C++ also supports C-style memory management functions from the <code>&lt;cstdlib&gt;</code> header.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

int main() {
    // malloc - allocate uninitialized memory
    int* ptr1 = (int*)malloc(sizeof(int));
    if (ptr1 == nullptr) {
        std::cerr &lt;&lt; "Memory allocation failed" &lt;&lt; std::endl;
        return 1;
    }
    *ptr1 = 42;
    std::cout &lt;&lt; "malloc allocated: " &lt;&lt; *ptr1 &lt;&lt; std::endl;
    free(ptr1);
    
    // calloc - allocate and initialize to zero
    int* ptr2 = (int*)calloc(5, sizeof(int));
    if (ptr2 == nullptr) {
        std::cerr &lt;&lt; "Memory allocation failed" &lt;&lt; std::endl;
        return 1;
    }
    
    std::cout &lt;&lt; "calloc allocated (zeroed): ";
    for (int i = 0; i < 5; i++) {
        std::cout &lt;&lt; ptr2[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    free(ptr2);
    
    // realloc - resize allocated memory
    int* ptr3 = (int*)malloc(3 * sizeof(int));
    if (ptr3 == nullptr) {
        std::cerr &lt;&lt; "Memory allocation failed" &lt;&lt; std::endl;
        return 1;
    }
    
    for (int i = 0; i < 3; i++) {
        ptr3[i] = i + 1;
    }
    
    std::cout &lt;&lt; "Before realloc: ";
    for (int i = 0; i < 3; i++) {
        std::cout &lt;&lt; ptr3[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    // Resize to 5 elements
    int* ptr4 = (int*)realloc(ptr3, 5 * sizeof(int));
    if (ptr4 == nullptr) {
        std::cerr &lt;&lt; "Memory reallocation failed" &lt;&lt; std::endl;
        free(ptr3);
        return 1;
    }
    
    // Initialize new elements
    for (int i = 3; i < 5; i++) {
        ptr4[i] = i + 1;
    }
    
    std::cout &lt;&lt; "After realloc: ";
    for (int i = 0; i < 5; i++) {
        std::cout &lt;&lt; ptr4[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    free(ptr4);
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>8.3 Memory Issues & Debugging</h3>
                        <p>Common memory management issues and how to debug them.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;
#include &lt;vector&gt;

// Example of memory leak
void memoryLeakExample() {
    int* leak = new int(42);
    // Missing delete leak; - this causes a memory leak
    std::cout &lt;&lt; "Memory leak created" &lt;&lt; std::endl;
}

// Example of dangling pointer
void danglingPointerExample() {
    int* ptr = new int(100);
    delete ptr;
    // ptr is now a dangling pointer
    // *ptr = 200;  // This would be undefined behavior
    std::cout &lt;&lt; "Dangling pointer created" &lt;&lt; std::endl;
}

// Example of double deletion
void doubleDeletionExample() {
    int* ptr = new int(200);
    delete ptr;
    // delete ptr;  // This would cause double deletion error
    std::cout &lt;&lt; "Double deletion avoided" &lt;&lt; std::endl;
}

// Safe memory management with RAII
class SafeResource {
private:
    int* data;
public:
    SafeResource(int value) : data(new int(value)) {
        std::cout &lt;&lt; "Resource acquired" &lt;&lt; std::endl;
    }
    
    ~SafeResource() {
        delete data;
        std::cout &lt;&lt; "Resource released" &lt;&lt; std::endl;
    }
    
    int getValue() const { return *data; }
    void setValue(int value) { *data = value; }
};

int main() {
    // Demonstrate memory issues
    memoryLeakExample();
    danglingPointerExample();
    doubleDeletionExample();
    
    // Safe memory management
    {
        SafeResource safe(300);
        std::cout &lt;&lt; "Safe resource value: " &lt;&lt; safe.getValue() &lt;&lt; std::endl;
        safe.setValue(400);
        std::cout &lt;&lt; "Modified value: " &lt;&lt; safe.getValue() &lt;&lt; std::endl;
    }  // Resource automatically released here
    
    // Using smart pointers for automatic memory management
    std::vector&lt;std::unique_ptr&lt;int&gt;&gt; smartPtrs;
    for (int i = 0; i < 5; i++) {
        smartPtrs.push_back(std::make_unique&lt;int&gt;(i * 100));
    }
    
    std::cout &lt;&lt; "Smart pointer values: ";
    for (const auto& ptr : smartPtrs) {
        std::cout &lt;&lt; *ptr &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    // Memory is automatically freed when smartPtrs goes out of scope
    
    return 0;
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>8.4 Advanced Memory Management</h3>
                        <p>Advanced techniques including custom allocators, memory pools, and placement new.</p>
                        
                        <div class="code-block">
                        <pre>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;

// Custom allocator example
template&lt;typename T&gt;
class CustomAllocator {
public:
    using value_type = T;
    
    CustomAllocator() noexcept = default;
    
    template&lt;typename U&gt;
    CustomAllocator(const CustomAllocator&lt;U&gt;&) noexcept {}
    
    T* allocate(std::size_t n) {
        std::cout &lt;&lt; "Allocating " &lt;&lt; n &lt;&lt; " elements" &lt;&lt; std::endl;
        return static_cast&lt;T*&gt;(::operator new(n * sizeof(T)));
    }
    
    void deallocate(T* p, std::size_t n) noexcept {
        std::cout &lt;&lt; "Deallocating " &lt;&lt; n &lt;&lt; " elements" &lt;&lt; std::endl;
        ::operator delete(p);
    }
};

// Memory pool example
class MemoryPool {
private:
    struct Block {
        Block* next;
    };
    
    Block* freeBlocks = nullptr;
    std::vector&lt;void*&gt; allocatedChunks;
    size_t blockSize;
    size_t blocksPerChunk;
    
public:
    MemoryPool(size_t blockSize, size_t blocksPerChunk = 100)
        : blockSize(blockSize), blocksPerChunk(blocksPerChunk) {}
    
    ~MemoryPool() {
        for (void* chunk : allocatedChunks) {
            ::operator delete(chunk);
        }
    }
    
    void* allocate() {
        if (freeBlocks == nullptr) {
            allocateChunk();
        }
        
        Block* block = freeBlocks;
        freeBlocks = freeBlocks->next;
        return block;
    }
    
    void deallocate(void* ptr) {
        Block* block = static_cast&lt;Block*&gt;(ptr);
        block->next = freeBlocks;
        freeBlocks = block;
    }
    
private:
    void allocateChunk() {
        char* chunk = static_cast&lt;char*&gt;(::operator new(blockSize * blocksPerChunk));
        allocatedChunks.push_back(chunk);
        
        for (size_t i = 0; i < blocksPerChunk; ++i) {
            Block* block = reinterpret_cast&lt;Block*&gt;(chunk + i * blockSize);
            block->next = freeBlocks;
            freeBlocks = block;
        }
    }
};

// Placement new example
class PlacementExample {
public:
    PlacementExample(int value) : data(value) {
        std::cout &lt;&lt; "PlacementExample constructed with value: " &lt;&lt; data &lt;&lt; std::endl;
    }
    
    ~PlacementExample() {
        std::cout &lt;&lt; "PlacementExample destroyed" &lt;&lt; std::endl;
    }
    
    int getData() const { return data; }
    
private:
    int data;
};

int main() {
    // Custom allocator usage
    std::vector&lt;int, CustomAllocator&lt;int&gt;&gt; customVector;
    customVector.push_back(1);
    customVector.push_back(2);
    customVector.push_back(3);
    
    // Memory pool usage
    MemoryPool pool(sizeof(int), 10);
    
    int* pooledInt1 = static_cast&lt;int*&gt;(pool.allocate());
    *pooledInt1 = 100;
    
    int* pooledInt2 = static_cast&lt;int*&gt;(pool.allocate());
    *pooledInt2 = 200;
    
    std::cout &lt;&lt; "Pooled integers: " &lt;&lt; *pooledInt1 &lt;&lt; ", " &lt;&lt; *pooledInt2 &lt;&lt; std::endl;
    
    pool.deallocate(pooledInt1);
    pool.deallocate(pooledInt2);
    
    // Placement new usage
    char buffer[sizeof(PlacementExample)];
    
    PlacementExample* placedObj = new (buffer) PlacementExample(42);
    std::cout &lt;&lt; "Placed object data: " &lt;&lt; placedObj->getData() &lt;&lt; std::endl;
    
    placedObj->~PlacementExample();
    
    return 0;
}</pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Due to the extensive nature of this guide, I'll continue with the remaining modules in a more condensed format -->
            
            <!-- Module 9: Structures & Classes -->
            <div class="module" id="module9">
                <div class="module-header" onclick="toggleModule(this)">
                    <h2>Module 9: Structures & Classes <span class="difficulty intermediate">Intermediate</span></h2>
                    <span class="toggle">â–¼</span>
                </div>
                <div class="module-content">
                    <div class="topic">
                        <h3>9.1 Structures</h3>
                        <div class="code-block">
                        <pre>struct Point {
    int x;
    int y;
    
    // Constructor
    Point(int x = 0, int y = 0) : x(x), y(y) {}
    
    // Member function
    void print() const {
        std::cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")";
    }
    
    // Static member
    static Point origin() { return Point(0, 0); }
};</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>9.2 Classes Fundamentals</h3>
                        <div class="code-block">
                        <pre>class Rectangle {
private:
    double width;
    double height;
    
public:
    // Constructor
    Rectangle(double w, double h) : width(w), height(h) {}
    
    // Public member functions
    double getArea() const { return width * height; }
    double getPerimeter() const { return 2 * (width + height); }
    
    // Setters
    void setWidth(double w) { width = w; }
    void setHeight(double h) { height = h; }
    
    // Getters
    double getWidth() const { return width; }
    double getHeight() const { return height; }
};</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>9.3 Constructors & Destructors</h3>
                        <div class="code-block">
                        <pre>class ResourceHandler {
private:
    int* resource;
    
public:
    // Default constructor
    ResourceHandler() : resource(new int(0)) {
        std::cout &lt;&lt; "Default constructor" &lt;&lt; std::endl;
    }
    
    // Parameterized constructor
    ResourceHandler(int value) : resource(new int(value)) {
        std::cout &lt;&lt; "Parameterized constructor" &lt;&lt; std::endl;
    }
    
    // Copy constructor
    ResourceHandler(const ResourceHandler& other) 
        : resource(new int(*other.resource)) {
        std::cout &lt;&lt; "Copy constructor" &lt;&lt; std::endl;
    }
    
    // Move constructor (C++11)
    ResourceHandler(ResourceHandler&& other) noexcept
        : resource(other.resource) {
        other.resource = nullptr;
        std::cout &lt;&lt; "Move constructor" &lt;&lt; std::endl;
    }
    
    // Destructor
    ~ResourceHandler() {
        delete resource;
        std::cout &lt;&lt; "Destructor" &lt;&lt; std::endl;
    }
    
    // Copy assignment operator
    ResourceHandler& operator=(const ResourceHandler& other) {
        if (this != &other) {
            delete resource;
            resource = new int(*other.resource);
        }
        std::cout &lt;&lt; "Copy assignment" &lt;&lt; std::endl;
        return *this;
    }
    
    // Move assignment operator (C++11)
    ResourceHandler& operator=(ResourceHandler&& other) noexcept {
        if (this != &other) {
            delete resource;
            resource = other.resource;
            other.resource = nullptr;
        }
        std::cout &lt;&lt; "Move assignment" &lt;&lt; std::endl;
        return *this;
    }
};</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>9.4 Advanced Class Features</h3>
                        <div class="code-block">
                        <pre>class AdvancedClass {
private:
    int value;
    mutable int accessCount;  // Can be modified in const methods
    
public:
    // Static members
    static int instanceCount;
    
    AdvancedClass(int v) : value(v), accessCount(0) {
        instanceCount++;
    }
    
    ~AdvancedClass() {
        instanceCount--;
    }
    
    // Const member function
    int getValue() const {
        accessCount++;  // Allowed because accessCount is mutable
        return value;
    }
    
    int getAccessCount() const { return accessCount; }
    
    // Static member function
    static int getInstanceCount() { return instanceCount; }
    
    // Friend function
    friend void friendFunction(AdvancedClass& obj);
    
    // Nested class
    class Nested {
    public:
        void print() { std::cout &lt;&lt; "Nested class" &lt;&lt; std::endl; }
    };
};

// Initialize static member
int AdvancedClass::instanceCount = 0;

// Friend function definition
void friendFunction(AdvancedClass& obj) {
    obj.value = 100;  // Can access private members
    std::cout &lt;&lt; "Friend function modified value" &lt;&lt; std::endl;
}</pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Module 10: Object-Oriented Programming -->
            <div class="module" id="module10">
                <div class="module-header" onclick="toggleModule(this)">
                    <h2>Module 10: Object-Oriented Programming <span class="difficulty advanced">Advanced</span></h2>
                    <span class="toggle">â–¼</span>
                </div>
                <div class="module-content">
                    <div class="topic">
                        <h3>10.1 Inheritance</h3>
                        <div class="code-block">
                        <pre>// Base class
class Shape {
protected:
    std::string name;
    
public:
    Shape(const std::string& n) : name(n) {}
    virtual ~Shape() = default;
    
    virtual double getArea() const = 0;
    virtual void draw() const {
        std::cout &lt;&lt; "Drawing " &lt;&lt; name &lt;&lt; std::endl;
    }
    
    std::string getName() const { return name; }
};

// Derived class
class Circle : public Shape {
private:
    double radius;
    
public:
    Circle(double r) : Shape("Circle"), radius(r) {}
    
    double getArea() const override {
        return 3.14159 * radius * radius;
    }
    
    void draw() const override {
        std::cout &lt;&lt; "Drawing circle with radius " &lt;&lt; radius &lt;&lt; std::endl;
    }
};

// Another derived class
class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(double w, double h) : Shape("Rectangle"), width(w), height(h) {}
    
    double getArea() const override {
        return width * height;
    }
    
    void draw() const override {
        std::cout &lt;&lt; "Drawing rectangle " &lt;&lt; width &lt;&lt; "x" &lt;&lt; height &lt;&lt; std::endl;
    }
};</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>10.2 Polymorphism</h3>
                        <div class="code-block">
                        <pre>// Abstract base class
class Animal {
public:
    virtual ~Animal() = default;
    virtual void makeSound() const = 0;
    virtual void move() const {
        std::cout &lt;&lt; "Animal moves" &lt;&lt; std::endl;
    }
};

// Concrete derived classes
class Dog : public Animal {
public:
    void makeSound() const override {
        std::cout &lt;&lt; "Woof!" &lt;&lt; std::endl;
    }
    
    void move() const override {
        std::cout &lt;&lt; "Dog runs" &lt;&lt; std::endl;
    }
};

class Cat : public Animal {
public:
    void makeSound() const override {
        std::cout &lt;&lt; "Meow!" &lt;&lt; std::endl;
    }
    
    void move() const override {
        std::cout &lt;&lt; "Cat walks gracefully" &lt;&lt; std::endl;
    }
};

// Polymorphic usage
void demonstratePolymorphism() {
    std::vector&lt;std::unique_ptr&lt;Animal&gt;&gt; animals;
    animals.push_back(std::make_unique&lt;Dog&gt;());
    animals.push_back(std::make_unique&lt;Cat&gt;());
    
    for (const auto& animal : animals) {
        animal->makeSound();  // Polymorphic call
        animal->move();
    }
}</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>10.3 Advanced Inheritance</h3>
                        <div class="code-block">
                        <pre>// Multiple inheritance
class Flyable {
public:
    virtual void fly() const {
        std::cout &lt;&lt; "Flying" &lt;&lt; std::endl;
    }
    virtual ~Flyable() = default;
};

class Swimmable {
public:
    virtual void swim() const {
        std::cout &lt;&lt; "Swimming" &lt;&lt; std::endl;
    }
    virtual ~Swimmable() = default;
};

// Multiple inheritance
class Duck : public Animal, public Flyable, public Swimmable {
public:
    void makeSound() const override {
        std::cout &lt;&lt; "Quack!" &lt;&lt; std::endl;
    }
    
    void fly() const override {
        std::cout &lt;&lt; "Duck flies" &lt;&lt; std::endl;
    }
    
    void swim() const override {
        std::cout &lt;&lt; "Duck swims" &lt;&lt; std::endl;
    }
};

// Virtual inheritance (diamond problem solution)
class Device {
public:
    virtual void powerOn() { std::cout &lt;&lt; "Device powered on" &lt;&lt; std::endl; }
    virtual ~Device() = default;
};

class Printer : virtual public Device {
public:
    void print() { std::cout &lt;&lt; "Printing" &lt;&lt; std::endl; }
};

class Scanner : virtual public Device {
public:
    void scan() { std::cout &lt;&lt; "Scanning" &lt;&lt; std::endl; }
};

class MultiFunctionDevice : public Printer, public Scanner {
public:
    void copy() {
        powerOn();
        scan();
        print();
    }
};</pre>
                        </div>
                    </div>

                    <div class="topic">
                        <h3>10.4 Runtime Type Information</h3>
                        <div class="code-block">
                        <pre>#include &lt;typeinfo&gt;
#include &lt;iostream&gt;

class Base {
public:
    virtual ~Base() = default;
    virtual void identify() const {
        std::cout &lt;&lt; "I am Base" &lt;&lt; std::endl;
    }
};

class Derived : public Base {
public:
    void identify() const override {
        std::cout &lt;&lt; "I am Derived" &lt;&lt; std::endl;
    }
};

void demonstrateRTTI() {
    Base* basePtr = new Derived();
    
    // typeid operator
    std::cout &lt;&lt; "Type of basePtr: " &lt;&lt; typeid(*basePtr).name() &lt;&lt; std::endl;
    
    // dynamic_cast
    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);
    if (derivedPtr) {
        std::cout &lt;&lt; "Successfully cast to Derived" &lt;&lt; std::endl;
        derivedPtr->identify();
    }
    
    // Check if cast failed
    Base* anotherBase = new Base();
    Derived* failedCast = dynamic_cast&lt;Derived*&gt;(anotherBase);
    if (!failedCast) {
        std::cout &lt;&lt; "Cast to Derived failed" &lt;&lt; std::endl;
    }
    
    // typeid with references
    try {
        Base& baseRef = *basePtr;
        const std::type_info& typeInfo = typeid(baseRef);
        std::cout &lt;&lt; "Reference type: " &lt;&lt; typeInfo.name() &lt;&lt; std::endl;
    } catch (const std::bad_typeid& e) {
        std::cout &lt;&lt; "Bad typeid: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    
    delete basePtr;
    delete anotherBase;
}</pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Navigation and completion message -->
            <div class="nav-buttons">
                <button class="nav-btn" onclick="previousModule()" id="prevBtn" disabled>Previous Module</button>
                <button class="nav-btn" onclick="nextModule()" id="nextBtn">Next Module</button>
            </div>

            <div class="module">
                <div class="module-header">
                    <h2>ðŸŽ‰ Congratulations! ðŸŽ‰</h2>
                </div>
                <div class="module-content">
                    <div class="topic">
                        <h3>You've Completed the C++ Master Guide!</h3>
                        <p>This comprehensive guide covers everything from basic C++ syntax to advanced C++23 features. Remember that becoming a C++ master requires:</p>
                        <ul>
                            <li><strong>Consistent Practice:</strong> Write code every day</li>
                            <li><strong>Build Projects:</strong> Apply what you've learned to real projects</li>
                            <li><strong>Read Code:</strong> Study open-source C++ projects</li>
                            <li><strong>Stay Updated:</strong> Keep up with new C++ standards</li>
                            <li><strong>Join Community:</strong> Participate in C++ forums and discussions</li>
                        </ul>
                        <p>Continue your journey by exploring specialized areas like game development, system programming, or high-performance computing with C++!</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        let currentModule = 0;
        const modules = document.querySelectorAll('.module');
        const totalModules = modules.length;

        function toggleModule(header) {
            const content = header.nextElementSibling;
            const isActive = content.classList.contains('active');
            
            // Close all modules
            document.querySelectorAll('.module-content').forEach(mc => {
                mc.classList.remove('active');
            });
            document.querySelectorAll('.module-header').forEach(mh => {
                mh.classList.remove('active');
            });
            
            // Open clicked module if it wasn't active
            if (!isActive) {
                content.classList.add('active');
                header.classList.add('active');
                
                // Update current module index
                const moduleElement = header.parentElement;
                currentModule = Array.from(modules).indexOf(moduleElement);
                updateProgress();
                updateNavigationButtons();
            }
        }

        function updateProgress() {
            const progress = ((currentModule + 1) / totalModules) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
            document.getElementById('progressText').textContent = Math.round(progress) + '%';
        }

        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            
            prevBtn.disabled = currentModule === 0;
            nextBtn.disabled = currentModule === totalModules - 1;
        }

        function nextModule() {
            if (currentModule < totalModules - 1) {
                currentModule++;
                const nextModuleElement = modules[currentModule];
                const header = nextModuleElement.querySelector('.module-header');
                const content = nextModuleElement.querySelector('.module-content');
                
                // Close all modules
                document.querySelectorAll('.module-content').forEach(mc => {
                    mc.classList.remove('active');
                });
                document.querySelectorAll('.module-header').forEach(mh => {
                    mh.classList.remove('active');
                });
                
                // Open next module
                content.classList.add('active');
                header.classList.add('active');
                
                updateProgress();
                updateNavigationButtons();
                
                // Scroll to module
                nextModuleElement.scrollIntoView({ behavior: 'smooth' });
            }
        }

        function previousModule() {
            if (currentModule > 0) {
                currentModule--;
                const prevModuleElement = modules[currentModule];
                const header = prevModuleElement.querySelector('.module-header');
                const content = prevModuleElement.querySelector('.module-content');
                
                // Close all modules
                document.querySelectorAll('.module-content').forEach(mc => {
                    mc.classList.remove('active');
                });
                document.querySelectorAll('.module-header').forEach(mh => {
                    mh.classList.remove('active');
                });
                
                // Open previous module
                content.classList.add('active');
                header.classList.add('active');
                
                updateProgress();
                updateNavigationButtons();
                
                // Scroll to module
                prevModuleElement.scrollIntoView({ behavior: 'smooth' });
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            updateProgress();
            updateNavigationButtons();
            
            // Open first module by default
            if (modules.length > 0) {
                const firstHeader = modules[0].querySelector('.module-header');
                const firstContent = modules[0].querySelector('.module-content');
                firstContent.classList.add('active');
                firstHeader.classList.add('active');
            }
        });

        // Smooth scrolling for sidebar links
        document.querySelectorAll('.sidebar a').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth' });
                    
                    // Open the target module
                    const header = targetElement.querySelector('.module-header');
                    const content = targetElement.querySelector('.module-content');
                    
                    // Close all modules
                    document.querySelectorAll('.module-content').forEach(mc => {
                        mc.classList.remove('active');
                    });
                    document.querySelectorAll('.module-header').forEach(mh => {
                        mh.classList.remove('active');
                    });
                    
                    // Open target module
                    content.classList.add('active');
                    header.classList.add('active');
                    
                    // Update current module index
                    currentModule = Array.from(modules).indexOf(targetElement);
                    updateProgress();
                    updateNavigationButtons();
                }
            });
        });
    </script>
</body>
</html>